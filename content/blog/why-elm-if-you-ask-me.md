---
title: "Why Elm if You Ask Me"
date: 2022-08-31
draft: true
---

Elm claims to produce code that does not have runtime exceptions. And according to various testimonials, it delivers on this promise. Imagine we embarked on this journey one day. It was scary and unknown at the beginning - a new paradigm, new restrictions, lots of learning, head-wall banging... but then we deployed a rewritten module, opened our monitoring tool next day, and... no exceptions. It's not broken - the log messages are there. But no exceptions. How would we react to that? I bet everyone would be proud.

I used Elm for many of my pet projects, and I know how it delivers. It is strict (yet easy to use). There will be no exceptions like cannot read property "length" of undefined or similar. There will be "errors" related to intention coded in the program. For example, we showed the wrong message to the user. But our program will never find itself in an exceptional state - a state a human forgot to think about. This is guaranteed by how the language is structured and how the compiler reads it.

A flexible type system (like one of TypeScript or JavaScript) allows for things like JSON.parse(response_body). Just how much uncertainty does this snippet convey? Is JSON well-formed? If so, do I get the data I expect? Can I trust the response? Imagine there are two teams, A and B. B uses the service maintained by A. Now A needs to change the response format. Just how much manual work it requires! There will be a meeting to discuss this, a document to be written, and B should write CDCs for A. And this is a tiny change! Now, how about teams B, C, D, E and F all depend on the response from A.... the meeting might not go so well, the document may be neglected, and CDC tests may not be complete... This is a dependency. More teams mean more dependencies and more fragile code. So, the best we can do is JSON.parse(...) and write the manual checks for every field. Manual. This is the problem. The bigger the data structure, the less motivation to write these stupid manual checks. So, it's easier to slack on it. A manual PR review may not help here. So much uncertainty! However, in Elm, you have no choice. As simple as that. It won't compile. You may not like it, and you may want to fall back to more liberal JS/TS, and you may argue this takes more time and hinders your productivity... But you are forced to decode the incoming data and deal with the fact that the decoding process may fail or succeed. There's no other way. Speaking of productivity, there's nothing "better" than debugging the runtime errors from the minified code. Now, we can mimic this decoding thing in TypeScript too. But this is a manual mimicking. Manual = error-prone.

Moreover, a small (and maybe marginal) ecosystem like Elm comes with standardised tools - compiler, code formatting tool, IDE. Rust has a similar toolbelt, for example. Imagine how much time and energy we could save by ditching Webpack. I am wondering what the environmental impact of our Webpack setup is. The problem with Webpack is the number of plugins required to make it work. Each plugin is a dependency with its own roadmap. Trying to upgrade from Webpack 4 to 5 requires a team of full-time specialists. Not only at Postman - in many other companies too. Yet, there's nothing better for TS/JS. I find it inefficient, to say the least.
