<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>typescript on Ivan's blog</title><link>https://raqystyle.github.io/tags/typescript/</link><description>Recent content in typescript on Ivan's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 29 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://raqystyle.github.io/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Common mistakes when using TypeScript</title><link>https://raqystyle.github.io/blog/common-mistakes-when-using-typescript/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://raqystyle.github.io/blog/common-mistakes-when-using-typescript/</guid><description>I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.
More often than not, we use TypeScript as bloated JavaScript. For example,
{ options: Record&amp;lt;string, string&amp;gt; } I would argue that this is why people keep saying that TypeScript doesn&amp;rsquo;t add much value.</description></item><item><title>Variadic attributes with TypeScripts Discriminated Unions</title><link>https://raqystyle.github.io/blog/variadic-attributes-with-typescripts-discriminated-unions/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://raqystyle.github.io/blog/variadic-attributes-with-typescripts-discriminated-unions/</guid><description>Sometimes, we need to create a component that serves multiple use-cases. As such, depending on some key attribute, the set of all others might differ. One example is a date picker component. Let&amp;rsquo;s see how we can implement it.
Imagine our date picker should allow a consumer to select a single date of a range of dates. Let&amp;rsquo;s try to visualise such use-cases:
&amp;lt;DatePicker onChange={handleOnChange} theDate={someDate} /&amp;gt; &amp;lt;DatePicker mode=&amp;#34;range&amp;#34; onStartDateChange={handleStartDateChange} onEndDateChange={handleEndDateChange} startDate={someStartDate} endDate={someEndDate} /&amp;gt; We can describe such behaviour in types like this:</description></item></channel></rss>