<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>typescript on Ivan's blog</title><link>https://raqystyle.github.io/tags/typescript/</link><description>Recent content in typescript on Ivan's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 09 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://raqystyle.github.io/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript is not viable any more</title><link>https://raqystyle.github.io/blog/js-is-not-viable-anymore/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://raqystyle.github.io/blog/js-is-not-viable-anymore/</guid><description>JavaScript is a dominant language for building web applications. I&amp;rsquo;ve been using it for a very long time. However, in my opinion, it just doesn&amp;rsquo;t cut it any more. Luckily, there are some compelling alternatives.
JavaScript: A Dominant Yet Flawed Language JavaScript offers a quick and cheap solution for building web applications in the short term. However, in the long run, its design quirks and inherent flaws will work against its users.</description></item><item><title>TypeScript inherits all the flaws of JavaScript</title><link>https://raqystyle.github.io/blog/js-and-ts-are-flawed-languages/</link><pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate><guid>https://raqystyle.github.io/blog/js-and-ts-are-flawed-languages/</guid><description>Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.
The problem Consider a function that turns an object representing a URL into a string:
type UrlRecord = { protocol: string; host: string[]; } function urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host.join(&amp;#39;.&amp;#39;)}`; } This code snippet looks innocent and pretty solid.</description></item><item><title>Common mistakes when using TypeScript</title><link>https://raqystyle.github.io/blog/common-mistakes-when-using-typescript/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://raqystyle.github.io/blog/common-mistakes-when-using-typescript/</guid><description>I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.
More often than not, we use TypeScript as bloated JavaScript. For example,
{ options: Record&amp;lt;string, string&amp;gt; } I would argue that this is why people keep saying that TypeScript doesn&amp;rsquo;t add much value.</description></item><item><title>Variadic attributes with TypeScripts Discriminated Unions</title><link>https://raqystyle.github.io/blog/variadic-attributes-with-typescripts-discriminated-unions/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://raqystyle.github.io/blog/variadic-attributes-with-typescripts-discriminated-unions/</guid><description>Sometimes, we need to create a component that serves multiple use-cases. As such, depending on some key attribute, the set of all others might differ. One example is a date picker component. Let&amp;rsquo;s see how we can implement it.
Imagine our date picker should allow a consumer to select a single date of a range of dates. Let&amp;rsquo;s try to visualise such use-cases:
&amp;lt;DatePicker onChange={handleOnChange} theDate={someDate} /&amp;gt; &amp;lt;DatePicker mode=&amp;#34;range&amp;#34; onStartDateChange={handleStartDateChange} onEndDateChange={handleEndDateChange} startDate={someStartDate} endDate={someEndDate} /&amp;gt; We can describe such behaviour in types like this:</description></item></channel></rss>