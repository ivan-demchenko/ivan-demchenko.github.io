<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>typescript on Ivan's blog</title><link>https://ivan-demchenko.github.io/tags/typescript/</link><description>Recent content in typescript on Ivan's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 29 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ivan-demchenko.github.io/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Remote Data as Data</title><link>https://ivan-demchenko.github.io/blog/remote-data-as-data/</link><pubDate>Wed, 29 Jan 2025 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/remote-data-as-data/</guid><description>Today I want to talk about an interesting (though not new) idea for representing remote resources. In fact, any resource that takes some time to retrieve. But most often we talk about network resources. At the same time, we&amp;rsquo;re going to do a bit of TypeScript gymnastics.
Data type for side effects The state of a remote resource can be represented in four ways:
Idle - we haven&amp;rsquo;t even requested the resource yet Loading - we have requested the resource, but the operation is not yet complete Ready&amp;lt;D&amp;gt; - we have the data Error&amp;lt;E&amp;gt; - something has gone wrong So, using a discriminated union feature of TypeScript, we can create a type for this situation:</description></item><item><title>Model errors as data for better user and developer experience</title><link>https://ivan-demchenko.github.io/blog/models-errors-as-data/</link><pubDate>Mon, 15 Jan 2024 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/models-errors-as-data/</guid><description>A great product experience is when the product works as expected in the scenario it was designed for, and communicates with users in a meaningful way. As developers, we cannot control how and where our product will be used, or the user input. But we have the tools to guard the flow from unexpected inputs. In this post, I want to give two pieces of advice for people working in the JS ecosystem on how to create better programs.</description></item><item><title>JavaScript is not viable any more</title><link>https://ivan-demchenko.github.io/blog/js-is-not-viable-anymore/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/js-is-not-viable-anymore/</guid><description>JavaScript is a dominant language for building web applications. I&amp;rsquo;ve been using it for a very long time. However, in my opinion, it just doesn&amp;rsquo;t cut it any more. Luckily, there are some compelling alternatives.
JavaScript: A Dominant Yet Flawed Language JavaScript offers a quick and cheap solution for building web applications in the short term. However, in the long run, its design quirks and inherent flaws will work against its users.</description></item><item><title>TypeScript inherits all the flaws of JavaScript</title><link>https://ivan-demchenko.github.io/blog/js-and-ts-are-flawed-languages/</link><pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/js-and-ts-are-flawed-languages/</guid><description>Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.
The problem Consider a function that turns an object representing a URL into a string:
type UrlRecord = { protocol: string; host: string[]; } function urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host.join(&amp;#39;.&amp;#39;)}`; } This code snippet looks innocent and pretty solid.</description></item><item><title>Common mistakes when using TypeScript</title><link>https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/</guid><description>I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.
More often than not, we use TypeScript as bloated JavaScript. For example,
{ options: Record&amp;lt;string, string&amp;gt; } I would argue that this is why people keep saying that TypeScript doesn&amp;rsquo;t add much value.</description></item><item><title>Variadic attributes with TypeScripts Discriminated Unions</title><link>https://ivan-demchenko.github.io/blog/variadic-attributes-with-typescripts-discriminated-unions/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/variadic-attributes-with-typescripts-discriminated-unions/</guid><description>Sometimes, we need to create a component that serves multiple use-cases. As such, depending on some key attribute, the set of all others might differ. One example is a date picker component. Let&amp;rsquo;s see how we can implement it.
Imagine our date picker should allow a consumer to select a single date of a range of dates. Let&amp;rsquo;s try to visualise such use-cases:
&amp;lt;DatePicker onChange={handleOnChange} theDate={someDate} /&amp;gt; &amp;lt;DatePicker mode=&amp;#34;range&amp;#34; onStartDateChange={handleStartDateChange} onEndDateChange={handleEndDateChange} startDate={someStartDate} endDate={someEndDate} /&amp;gt; We can describe such behaviour in types like this:</description></item></channel></rss>