<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>front-end on Ivan's blog</title><link>https://ivan-demchenko.github.io/tags/front-end/</link><description>Recent content in front-end on Ivan's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 05 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://ivan-demchenko.github.io/tags/front-end/index.xml" rel="self" type="application/rss+xml"/><item><title>The Freedom of Web Components or Why UI Libraries Should Embrace Framework-Agnostic Solutions</title><link>https://ivan-demchenko.github.io/blog/web-components-for-ui-lib/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/web-components-for-ui-lib/</guid><description>In the ever-evolving landscape of web development, the choice of tools and technologies can have a profound impact on the flexibility, scalability, and longevity of a code base. One critical decision that developers often face is whether to use a framework or embrace more framework-agnostic solutions like Web Components when building a UI library. In this post, we&amp;rsquo;ll explore why opting for Web Components can offer unparalleled advantages when it comes to ensuring flexibility and avoiding lock-in.</description></item><item><title>Use Tailwind as CSS abstraction in CSS modules</title><link>https://ivan-demchenko.github.io/blog/use-tailwind-with-abstration/</link><pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/use-tailwind-with-abstration/</guid><description>Tailwind provides a solid base level, sort of a starting point for your application. The library is a set of utility CSS classes that use Custom CSS properties (a.k.a CSS variables). Some of these variables abstract away a default set of design tokens. As such, it is easy to create a dark theme (should a user prefer dark mode) or take some accessibility aspect into account (like reduced animations). I only described the tip of the iceberg.</description></item><item><title>UI library as a mono-repository. Part 3</title><link>https://ivan-demchenko.github.io/blog/ui-lib-monorepo-part3/</link><pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/ui-lib-monorepo-part3/</guid><description>As we progressed with our mono-repository endeavour, we noticed some weird behaviour. It worked like charm in the apps. But not in our Storybook. Besides, sometimes tests would fail for no obvious reason.
Storybook is a de-facto standard tool for developing and demonstrating your components in action in the real environment. We also used Jest for testing. So, naturally, we didn&amp;rsquo;t want to give them up. Seems like our setup is not finished yet.</description></item><item><title>UI library as a mono-repository. Part 2</title><link>https://ivan-demchenko.github.io/blog/ui-lib-monorepo-part2/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/ui-lib-monorepo-part2/</guid><description>Let&amp;rsquo;s talk about CSS files and modules. Unfortunately, they are often treated as if they were a second class entities. We need to fix this situation.
Treating CSS dependencies the way we treat other dependencies Let&amp;rsquo;s talk about the dependencies between UI components.
In JS files, we mark dependencies by import-ing or require-ing them. Packages clearly define dependencies in the package.json file. But a package is not only JS files, but also CSS files.</description></item><item><title>UI library as a mono-repository. Part 1</title><link>https://ivan-demchenko.github.io/blog/ui-lib-monorepo-part1/</link><pubDate>Mon, 25 Oct 2021 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/ui-lib-monorepo-part1/</guid><description>Welcome to the first instalment of the series dedicated to the re-architecture of a UI library. I helped my company to transition from the monolithic setup to a mono-repository by leading this project.
This is all very familiar It seems like this is a common topic these days: Deprecate monoliths and move toward micro-frontend/micro-service architecture.
However, many UI libraries start as a monolith. Meaning, there&amp;rsquo;s a single distribution for the whole library.</description></item><item><title>One more way to implement a carousel</title><link>https://ivan-demchenko.github.io/blog/one-more-way-to-implement-a-carousel/</link><pubDate>Tue, 30 Aug 2016 00:00:00 +0000</pubDate><guid>https://ivan-demchenko.github.io/blog/one-more-way-to-implement-a-carousel/</guid><description>There are lots of implementations of it: jQuery based, vanilla-js based, heavy and lightweight. Some even claim that their solution is the only one you might ever need. However, there will always be a situation when the existing solution simply doesnâ€™t work.
Here, at AutoScout24 we just had such situation and we decided to implement our own Carousel. We called it showcar-carousel. Please, do not hesitate to check the code out on GitHub repo for showcar-carousel.</description></item></channel></rss>