<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Is JavaScript OOP or Functional? | Ivan's blog</title><meta name=keywords content="JavaScript"><meta name=description content="A colleague of mine asked a good question: does TypeScript make JavaScript a better OOP language? To answer this question, I decided to compare OOP JavaScript to its opposite, Functional JavaScript.
TypeScript has become crazy popular. Many people bet on it as a magical language that will solve their JavaScript problems. Well, it won&rsquo;t. As Kyle Simpson described in his upcoming book, the quirks of JavaScript don&rsquo;t disappear. In my opinion, we should not attribute any superpowers to TS apart from just helping developers to feel more confident in the larger codebase."><meta name=author content><link rel=canonical href=https://ivan-demchenko.github.io/blog/is-js-oop-or-functional/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://ivan-demchenko.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://ivan-demchenko.github.io/static/icon32.png><link rel=apple-touch-icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=mask-icon href=https://ivan-demchenko.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="Is JavaScript OOP or Functional?"><meta property="og:description" content="A colleague of mine asked a good question: does TypeScript make JavaScript a better OOP language? To answer this question, I decided to compare OOP JavaScript to its opposite, Functional JavaScript.
TypeScript has become crazy popular. Many people bet on it as a magical language that will solve their JavaScript problems. Well, it won&rsquo;t. As Kyle Simpson described in his upcoming book, the quirks of JavaScript don&rsquo;t disappear. In my opinion, we should not attribute any superpowers to TS apart from just helping developers to feel more confident in the larger codebase."><meta property="og:type" content="article"><meta property="og:url" content="https://ivan-demchenko.github.io/blog/is-js-oop-or-functional/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-31T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-31T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Is JavaScript OOP or Functional?"><meta name=twitter:description content="A colleague of mine asked a good question: does TypeScript make JavaScript a better OOP language? To answer this question, I decided to compare OOP JavaScript to its opposite, Functional JavaScript.
TypeScript has become crazy popular. Many people bet on it as a magical language that will solve their JavaScript problems. Well, it won&rsquo;t. As Kyle Simpson described in his upcoming book, the quirks of JavaScript don&rsquo;t disappear. In my opinion, we should not attribute any superpowers to TS apart from just helping developers to feel more confident in the larger codebase."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ivan-demchenko.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Is JavaScript OOP or Functional?","item":"https://ivan-demchenko.github.io/blog/is-js-oop-or-functional/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Is JavaScript OOP or Functional?","name":"Is JavaScript OOP or Functional?","description":"A colleague of mine asked a good question: does TypeScript make JavaScript a better OOP language? To answer this question, I decided to compare OOP JavaScript to its opposite, Functional JavaScript.\nTypeScript has become crazy popular. Many people bet on it as a magical language that will solve their JavaScript problems. Well, it won\u0026rsquo;t. As Kyle Simpson described in his upcoming book, the quirks of JavaScript don\u0026rsquo;t disappear. In my opinion, we should not attribute any superpowers to TS apart from just helping developers to feel more confident in the larger codebase.","keywords":["JavaScript"],"articleBody":"A colleague of mine asked a good question: does TypeScript make JavaScript a better OOP language? To answer this question, I decided to compare OOP JavaScript to its opposite, Functional JavaScript.\nTypeScript has become crazy popular. Many people bet on it as a magical language that will solve their JavaScript problems. Well, it won’t. As Kyle Simpson described in his upcoming book, the quirks of JavaScript don’t disappear. In my opinion, we should not attribute any superpowers to TS apart from just helping developers to feel more confident in the larger codebase. As we know, all the type annotations are wiped out, and all we have left is pretty much JavaScript. Yes, the compiler may add some boilerplate code, like the inheritance implementation (depending on what is in the tsconfig.json file).\nIn my opinion, JS/TS is closer to the OOP language. The simplest reason is the syntax. Let me explain my point. We often need to provide an environment for computation. Here’s a simple example:\nlet a = 1; let b = 2; let c = a + b; Here, the computation is a + b. The environment is the JS global context. Another way of doing this is via a function:\nfunction sum(a, b) { return a + b; } The context created by the sum function is the environment for that computation. If we use a bit more language-independent annotation, it may look like this: sum :: (num, num) -\u003e num. The env here is a tuple (num, num).\nA similar thing happens when we start an app, and the program reads from a .env file. We create an environment (via a different mechanism) and provide some values to our computation.\nIn functional languages, people use a Reader monad. Why “Reader”? Because this monad provides a read-only env for a computation. Typically, we first build-up the definition of that computation and then run it:\nrun :: (env -\u003e a) -\u003e env -\u003e a. In other words, we provide a function that depends on env and later an env itself and get the result back. The env can look, for example, like this: { db_connection, file_system, port_number }. In Haskell, it looks elegant because the syntax allows that.\nThe Reader monad reminds me of the Dependency Injection mechanism. Also, it makes me think of the Dependency Inversion principle. Don’t we strive to do that in our day job to make the code more modular and testable?\nThere are implementations of the Reader monad for JS and TS too. However, they look unnatural in JS syntax. It’s a matter of taste, of course. But some people like it and eventually switch to PureScript.\nIn JS, it is more natural or elegant (the path of the least resistance) to create a class and pass its dependencies via a constructor. TypeScript simply allows having more confidence here by specifying interfaces. And if there’s a mismatch, your good and tireless friend will tell you. No code review process or unit testing can give that level of confidence. Of course, unit tests still play a vital role. But when you have a type system next to you, you think about what needs to be tested differently as you trust the compiler. The same applies to assertions in code.\nStill, correct me if I am wrong (I don’t remember the last time I opened the spec), but classes are syntactic sugar. Essentially, the new operator will act pretty much the same for class A { constructor(dep) {} } and function A(dep) {}?\n","wordCount":"587","inLanguage":"en","datePublished":"2022-08-31T00:00:00Z","dateModified":"2022-08-31T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivan-demchenko.github.io/blog/is-js-oop-or-functional/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://ivan-demchenko.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ivan-demchenko.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ivan-demchenko.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://ivan-demchenko.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ivan-demchenko.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ivan-demchenko.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Is JavaScript OOP or Functional?</h1><div class=post-meta><span title='2022-08-31 00:00:00 +0000 UTC'>August 31, 2022</span>&nbsp;·&nbsp;3 min&nbsp;|&nbsp;<a href=https://github.com/ivan-demchenko/ivan-demchenko.github.io/blog/2022-08-31-is-js-oop-or-functional.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>A colleague of mine asked a good question: does TypeScript make JavaScript a better OOP language? To answer this question, I decided to compare OOP JavaScript to its opposite, Functional JavaScript.</p><p>TypeScript has become crazy popular. Many people bet on it as a magical language that will solve their JavaScript problems. Well, it won&rsquo;t. As Kyle Simpson described in his <a href=https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md>upcoming book</a>, the quirks of JavaScript don&rsquo;t disappear. In my opinion, we should not attribute any superpowers to TS apart from just helping developers to feel more confident in the larger codebase. As we know, all the type annotations are wiped out, and all we have left is pretty much JavaScript. Yes, the compiler may add some boilerplate code, like the inheritance implementation (depending on what is in the <code>tsconfig.json</code> file).</p><p>In my opinion, JS/TS is closer to the OOP language. The simplest reason is the syntax. Let me explain my point. We often need to provide an environment for computation. Here&rsquo;s a simple example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>;
</span></span></code></pre></div><p>Here, the computation is <code>a + b</code>. The environment is the JS global context. Another way of doing this is via a function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The context created by the sum function is the environment for that computation. If we use a bit more language-independent annotation, it may look like this: <code>sum :: (num, num) -> num</code>. The env here is a tuple <code>(num, num)</code>.</p><p>A similar thing happens when we start an app, and the program reads from a <code>.env</code> file. We create an environment (via a different mechanism) and provide some values to our computation.</p><p>In functional languages, people use a Reader monad. Why &ldquo;Reader&rdquo;? Because this monad provides a read-only env for a computation. Typically, we first build-up the definition of that computation and then run it:</p><pre tabindex=0><code>run :: (env -&gt; a) -&gt; env -&gt; a.
</code></pre><p>In other words, we provide a function that depends on <code>env</code> and later an <code>env</code> itself and get the result back. The <code>env</code> can look, for example, like this: <code>{ db_connection, file_system, port_number }</code>. In Haskell, it looks elegant because the syntax allows that.</p><p>The Reader monad reminds me of the Dependency Injection mechanism. Also, it makes me think of the Dependency Inversion principle. Don&rsquo;t we strive to do that in our day job to make the code more modular and testable?</p><p>There are implementations of the Reader monad for JS and TS too. However, they look unnatural in JS syntax. It&rsquo;s a matter of taste, of course. But some people like it and eventually switch to PureScript.</p><p>In JS, it is more natural or elegant (the path of the least resistance) to create a class and pass its dependencies via a constructor. TypeScript simply allows having more confidence here by specifying interfaces. And if there&rsquo;s a mismatch, your good and tireless friend will tell you. No code review process or unit testing can give that level of confidence. Of course, unit tests still play a vital role. But when you have a type system next to you, you think about what needs to be tested differently as you trust the compiler. The same applies to assertions in code.</p><p>Still, correct me if I am wrong (I don&rsquo;t remember the last time I opened the spec), but classes are syntactic sugar. Essentially, the <code>new</code> operator will act pretty much the same for
<code>class A { constructor(dep) {} }</code> and <code>function A(dep) {}</code>?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ivan-demchenko.github.io/tags/javascript/>JavaScript</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ivan-demchenko.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript>var sc_project=12781072,sc_invisible=1,sc_security="4d31877b"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12781072/0/4d31877b/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>