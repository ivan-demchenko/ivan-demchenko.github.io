<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Common mistakes when using TypeScript | Ivan's blog</title><meta name=keywords content="engineering,typescript,type systems,large codebase"><meta name=description content="I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.
More often than not, we use TypeScript as bloated JavaScript. For example,
{ options: Record<string, string> } I would argue that this is why people keep saying that TypeScript doesn&rsquo;t add much value."><meta name=author content><link rel=canonical href=https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://ivan-demchenko.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://ivan-demchenko.github.io/static/icon32.png><link rel=apple-touch-icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=mask-icon href=https://ivan-demchenko.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="Common mistakes when using TypeScript"><meta property="og:description" content="I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.
More often than not, we use TypeScript as bloated JavaScript. For example,
{ options: Record<string, string> } I would argue that this is why people keep saying that TypeScript doesn&rsquo;t add much value."><meta property="og:type" content="article"><meta property="og:url" content="https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/"><meta property="og:image" content="https://ivan-demchenko.github.io/cover-image.jpg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-08-29T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-29T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ivan-demchenko.github.io/cover-image.jpg"><meta name=twitter:title content="Common mistakes when using TypeScript"><meta name=twitter:description content="I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.
More often than not, we use TypeScript as bloated JavaScript. For example,
{ options: Record<string, string> } I would argue that this is why people keep saying that TypeScript doesn&rsquo;t add much value."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ivan-demchenko.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Common mistakes when using TypeScript","item":"https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Common mistakes when using TypeScript","name":"Common mistakes when using TypeScript","description":"I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.\nMore often than not, we use TypeScript as bloated JavaScript. For example,\n{ options: Record\u0026lt;string, string\u0026gt; } I would argue that this is why people keep saying that TypeScript doesn\u0026rsquo;t add much value.","keywords":["engineering","typescript","type systems","large codebase"],"articleBody":"I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.\nMore often than not, we use TypeScript as bloated JavaScript. For example,\n{ options: Record\u003cstring, string\u003e } I would argue that this is why people keep saying that TypeScript doesn’t add much value. In fact, this type tells me (or the users of my code) nothing about what the options are. Consider another example:\n{ someField: string, [key: string]: unknown; } This is a fairly pointless type either.\nThe problem is that we think we have added value. In fact, all we did was ask the compiler to keep it quiet.\nWhy use types at all? The main reason people use types is to avoid ambiguity and increase confidence. Let’s be honest: can you imagine a large codebase all written entirely in JavaScript? Sure, it is possible. But eventually, we would have to implement all kinds of runtime checks and unit tests to verify things that the compiler could have verified. The cost of maintenance of such a codebase is much higher compared to a strongly typed one.\nOkay, let’s step aside a bit. Consider the following snippet:\nif (val !== null) { doSomething(val) } This is a cliffhanger! What if the value is null? This is our job to think about the scenarios like this.\nBy the way, the exceptions are called exceptions because the computer ended up in an exceptional state. In other words, the way forward is not defined.\nBy writing code, we tell the computer to perform certain actions instead of us. But machines will strictly follow the instructions we give them. The program is the most accurate specification. So it is our job to make sure we don’t leave black spaces in this spec. And if the flow of execution is stuck, the best the machine can do is crash the program.\nAs you know, many languages avoid exceptions, nulls, undefined, any and those weird constructs listed above. This is to ensure that programmers cannot ship the code shown in the image above. For example, Rust uses Result instead of null (with two variants - Ok and Err, which the programmer has to deal with). In Haskell, the programmer has to provide the else case. All this makes the flow of the program as defined as a railway system. No sudden interruptions. No run-time exceptions. Just an angry compiler.\nTypeScript was born out of desperation because there were no types in JS, JS was the only option at the time, and the browser was becoming the platform. In other words, JS programs have been becoming ever more complex without a way to verify the correctness of those without involving people. However, to make it easier to adopt, TS introduced the escape hatches. Otherwise, it could easily have become another PureScript (which is an amazing language, much more shippable, but harder to adopt). That’s why we have to deal not only with exceptions, nulls and undefineds, but also with all sorts of weird object-like constructs and anys.\nBut we don’t have to.\nNarrow down the options Guessing while coding takes a lot of energy, causes frustration, and leads to philosophical discussions in the nearest bar. TypeScript can help avoid this. Consider this (let’s say we were maintaining this code):\ntype Event = { // some fields action?: { type: string [key: string]: unknown } // more fields } This is a piece of valid TypeScript code. How many questions does this code snippet raise? First of all, why is action optional? What does that mean from the business logic perspective? Secondly, we’ll have to guess (using find/grep, maybe) the type of the action. The string type is not an ideal choice here as most probably, down the road, we’ll have to match that string with some other finite set of strings. Lastly, the fact that this action object can have whatever key with an unknown value doesn’t help at all. We’ll have to use find/grep again to understand it. TypeScript will swallow this code, no problem. But we, humans, will have to come back to it after a while. So, as long as we’re not ready to adopt less forgiving language, it’s up to us to make it better.\nSo, what can we do differently?\nList your options, define the pathways.\nInstead of using optional fields, use union type. For example, we could say, we have an “actionable event” or just a “data event”:\ntype Event = | { type: 'ACTIONABLE', action: {...}, ... } // #1 | { type: 'DATA', ... } // #2 The consumer will have just two, self-describing variants to deal with:\nfunction handle(e: Event): void { if (e.type === 'ACTIONABLE') { // tsc knows this is the branch #1 return; } // tsc knows this is the branch #2 return; } (Playground)\nAdding another path in our code (another type of event) becomes a lot easier. Moreover, this kind of code reflects the domain knowledge. TypeScript is very good at making types out of strings, we should leverage that!\nBy the way, an If is like a fork, and a Switch is like a mega-fork - either way, there are well-defined branches of the execution flow.\nAvoid using optional keys on objects.\nJust look at it ?: - is it a broken smiley? Apart from jokes, if an object may or may not contain a key, this means something from the business logic perspective. it is always a sign of a fork down the road (like, obj.key ? myFn(obj.key) : otherFn()). So, why not make it explicit (like we did with the Event above) and distinguish both variants?\nAvoid vague records\nThings like Record are very convenient at the moment of writing, but defeat the purpose of having a type system in the long run. This is an escape hatch, so do try to avoid it. I would argue that it is better to use unknown in this case because TS will force runtime checks. For example,\nconst bad: Record\u003cstring, string\u003e = {}; const better: unknown = {}; const a = bad.abc; // happy TS const b = better.abc; // angry TS // We need to convince TS that we know what we are doing. if (typeof better === 'object' \u0026\u0026 better !== null \u0026\u0026 'abc' in better) { const c = better.abc; // happy TS } Without that convincing, our program would not compile (playground).\nI understand that sometimes (rather rarely though) we really don’t know the keys and the values. Maybe our code shouldn’t even know about them. But think twice before introducing this escape hatch.\nUse Result instead of throwing exceptions\nThe hype around Rust’s Result type is real and it was ported to TS. Let me introduce ts-results - a wonderful little library that can help with avoiding all the issues associated with the exceptions.\nThe main idea is that your function should always return. Your program is in the flow, don’t interrupt it! So instead of this:\nfunction divide(a: number, b: number): number { // this is an incomplete truth, btw if(b===0){ if (b === 0) { throw new Error('Dividing by zero?'); // the flow is interrupted, the program doesn't return // the user should know about it and wrap it in try-catch // we can sneak in an exception, nobody will notice until it blows up :P } return a/b; } … we can use this:\nexport type MathError = | { type: 'DIVISION_BY_ZERO' } | { type: '...' } | { type: '...' }; function divide(a: number, b: number): Result\u003cnumber, MathError\u003e { if (b === 0) { return new Err({ type: 'DIVISION_BY_ZERO' }) } return new Ok(a/b); } Notice how we listed all the errors we could think of and we always return a value from the function. The caller of the function now has clearly defined two paths to follow - Ok | Err. By the way, you can .map or .mapErr over the Result type and the code results in a beautiful linear railroad.\nConclusion I wanna wrap it up with ChatGTP-generated Hokku:\nIn typed code’s embrace, Errors fade like morning mist, Maintained with surety.\n","wordCount":"1400","inLanguage":"en","image":"https://ivan-demchenko.github.io/cover-image.jpg","datePublished":"2023-08-29T00:00:00Z","dateModified":"2023-08-29T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://ivan-demchenko.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ivan-demchenko.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ivan-demchenko.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://ivan-demchenko.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ivan-demchenko.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ivan-demchenko.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li><li><a href=https://ivan-demchenko.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Common mistakes when using TypeScript</h1><div class=post-meta><span title='2023-08-29 00:00:00 +0000 UTC'>August 29, 2023</span>&nbsp;·&nbsp;7 min&nbsp;|&nbsp;<a href=https://github.com/ivan-demchenko/ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy srcset="https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/cover-image_hu3d03a01dcc18bc5be0e67db3d8d209a6_1113803_360x0_resize_q75_box.jpg 360w ,https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/cover-image_hu3d03a01dcc18bc5be0e67db3d8d209a6_1113803_480x0_resize_q75_box.jpg 480w ,https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/cover-image_hu3d03a01dcc18bc5be0e67db3d8d209a6_1113803_720x0_resize_q75_box.jpg 720w ,https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/cover-image_hu3d03a01dcc18bc5be0e67db3d8d209a6_1113803_1080x0_resize_q75_box.jpg 1080w ,https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/cover-image_hu3d03a01dcc18bc5be0e67db3d8d209a6_1113803_1500x0_resize_q75_box.jpg 1500w ,https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/cover-image.jpg 3543w" sizes="(min-width: 768px) 720px, 100vw" src=https://ivan-demchenko.github.io/blog/common-mistakes-when-using-typescript/cover-image.jpg alt="Photo by Wolfgang Rottmann on Unsplash" width=3543 height=2362><p>Photo by Wolfgang Rottmann on Unsplash</p></figure><div class=post-content><p>I chose the railway photo for the cover for a reason. TypeScript as a type system has many powerful and unique features. But people often do not know about them or neglect them. In this post, I want to highlight some common escape hatches that people use and why they make TypeScript feel like bloated JavaScript.</p><p>More often than not, we use TypeScript as bloated JavaScript. For example,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>options</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>string</span>&gt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I would argue that this is why people keep saying that TypeScript doesn&rsquo;t add much value. In fact, this type tells me (or the users of my code) nothing about what the options are. Consider another example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>someField</span>: <span style=color:#66d9ef>string</span>,
</span></span><span style=display:flex><span>  [<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#66d9ef>unknown</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a fairly pointless type either.</p><p>The problem is that we think we have added value. In fact, all we did was ask the compiler to keep it quiet.</p><h2 id=why-use-types-at-all>Why use types at all?<a hidden class=anchor aria-hidden=true href=#why-use-types-at-all>#</a></h2><p>The main reason people use types is to avoid ambiguity and increase confidence. Let’s be honest: can you imagine a large codebase all written entirely in JavaScript? Sure, it is possible. But eventually, we would have to implement all kinds of runtime checks and unit tests to verify things that the compiler could have verified. The cost of maintenance of such a codebase is much higher compared to a strongly typed one.</p><p>Okay, let’s step aside a bit. Consider the following snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>val</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a cliffhanger! What if the value is <code>null</code>? This is our job to think about the scenarios like this.</p><p>By the way, the exceptions are called exceptions because the computer ended up in an exceptional state. In other words, the way forward is not defined.</p><p><img loading=lazy src=./road-fork.png alt="an if statement is like a road fork"></p><p>By writing code, we tell the computer to perform certain actions instead of us. But machines will strictly follow the instructions we give them. The program is the most accurate specification. So it is our job to make sure we don’t leave black spaces in this spec. And if the flow of execution is stuck, the best the machine can do is crash the program.</p><p><img loading=lazy src=./developers-code-ai-meme.jpeg alt="developers thinking about ai writing programs"></p><p>As you know, many languages avoid <code>exceptions</code>, <code>nulls</code>, <code>undefined</code>, <code>any</code> and those weird constructs listed above. This is to ensure that programmers cannot ship the code shown in the image above. For example, Rust <a href=https://doc.rust-lang.org/std/result/>uses</a> <code>Result</code> instead of <code>null</code> (with two variants - <code>Ok</code> and <code>Err</code>, which the programmer has to deal with). In Haskell, the programmer <a href=https://en.wikibooks.org/wiki/Haskell/Control_structures>has to provide</a> the <code>else</code> case. All this makes the flow of the program as defined as a railway system. No sudden interruptions. No run-time exceptions. Just an angry compiler.</p><p>TypeScript was born out of desperation because there were no types in JS, JS was the only option at the time, and the browser was becoming the platform. In other words, JS programs have been becoming ever more complex without a way to verify the correctness of those without involving people. However, to make it easier to adopt, TS introduced the escape hatches. Otherwise, it could easily have become another <a href=https://www.purescript.org/>PureScript</a> (which is an amazing language, much more shippable, but harder to adopt). That&rsquo;s why we have to deal not only with <code>exception</code>s, <code>null</code>s and <code>undefined</code>s, but also with all sorts of weird object-like constructs and <code>any</code>s.</p><p>But we don’t have to.</p><h2 id=narrow-down-the-options>Narrow down the options<a hidden class=anchor aria-hidden=true href=#narrow-down-the-options>#</a></h2><p>Guessing while coding takes a lot of energy, causes frustration, and leads to philosophical discussions in the nearest bar. TypeScript can help avoid this. Consider this (let&rsquo;s say we were maintaining this code):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// some fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>action</span><span style=color:#f92672>?:</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    [<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#66d9ef>unknown</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// more fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This is a piece of valid TypeScript code. How many questions does this code snippet raise? First of all, why is <code>action</code> optional? What does that mean from the business logic perspective? Secondly, we&rsquo;ll have to guess (using find/grep, maybe) the <code>type</code> of the action. The <code>string</code> type is not an ideal choice here as most probably, down the road, we’ll have to match that string with some other finite set of strings. Lastly, the fact that this <code>action</code> object can have whatever key with an <code>unknown</code> value doesn’t help at all. We’ll have to use find/grep again to understand it. TypeScript will swallow this code, no problem. But we, humans, will have to come back to it after a while. So, as long as we’re not ready to adopt less forgiving language, it’s up to us to make it better.</p><p>So, what can we do differently?</p><blockquote><p>List your options, define the pathways.</p></blockquote><p>Instead of using optional fields, use union type. For example, we could say, we have an “actionable event” or just a “data event”:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> { <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;ACTIONABLE&#39;</span>, <span style=color:#a6e22e>action</span><span style=color:#f92672>:</span> {...}, ... }  <span style=color:#75715e>// #1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>|</span> { <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;DATA&#39;</span>, ... }                       <span style=color:#75715e>// #2
</span></span></span></code></pre></div><p>The consumer will have just two, self-describing variants to deal with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handle</span>(<span style=color:#a6e22e>e</span>: <span style=color:#66d9ef>Event</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>e</span>.<span style=color:#66d9ef>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;ACTIONABLE&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// tsc knows this is the branch #1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// tsc knows this is the branch #2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(<a href="https://www.typescriptlang.org/play?useUnknownInCatchVariables=true#code/C4TwDgpgBAQghgZwgFXNAvFA3lAdnAWwgC4oFgAnAS1wHMAaKOWkvAVwICMIKoBfANwAoUJCgB5AMaS2YRFQD2uKOiFR1sRCjRQAZFAAUajSYA+2KKNYBycmwAmEXMGuN7VADZUWz0pwUKHhBwynzGJurmOFak1mAUCgBmEAgIChSuUIH2AMqSABYBHn5FwaHhUACUwkKJbLiSwIrK8TTAOcBsiYkGkBRpuKRSMnIIzZWkAG4KVPbYFVSJhn0DAHRWKuiYtp2OztaV8xEakkppQaseCrQG1gCSUADWuAoA7pb5VAhku04ujCslKt3F4fMBqhUTBQIJ0KLhhCYwiZTrhzhBLtdbg9nm8Pl8oPEkik0hkATw1tk8oVApUhHwgA">Playground</a>)</p><p>Adding another path in our code (another type of event) becomes a lot easier. Moreover, this kind of code reflects the domain knowledge. TypeScript is very good at making types out of strings, we should leverage that!</p><p>By the way, an <code>If</code> is like a fork, and a <code>Switch</code> is like a mega-fork - either way, there are well-defined branches of the execution flow.</p><p><img loading=lazy src=./if-vs-switch.png alt="if statement compared to a switch statement"></p><blockquote><p>Avoid using optional keys on objects.</p></blockquote><p>Just look at it ?: - is it a broken smiley? Apart from jokes, if an object may or may not contain a key, this means something from the business logic perspective. it is always a sign of a fork down the road (like, <code>obj.key ? myFn(obj.key) : otherFn()</code>). So, why not make it explicit (like we did with the Event above) and distinguish both variants?</p><blockquote><p>Avoid vague records</p></blockquote><p>Things like <code>Record&lt;string, string></code> are very convenient at the moment of writing, but defeat the purpose of having a type system in the long run. This is an escape hatch, so do try to avoid it. I would argue that it is better to use unknown in this case because TS will force runtime checks. For example,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bad</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>string</span>&gt; <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>better</span>: <span style=color:#66d9ef>unknown</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>bad</span>.<span style=color:#a6e22e>abc</span>; <span style=color:#75715e>// happy TS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>better</span>.<span style=color:#a6e22e>abc</span>; <span style=color:#75715e>// angry TS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// We need to convince TS that we know what we are doing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>better</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;object&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>better</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#39;abc&#39;</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>better</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>better</span>.<span style=color:#a6e22e>abc</span>; <span style=color:#75715e>// happy TS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Without that convincing, our program would not compile (<a href="https://www.typescriptlang.org/play?useUnknownInCatchVariables=true#code/MYewdgzgLgBARgQwCYC4YCUCmoBOSA80OAlmAOYA0MRpZAfDALwwDeAvgNwBQokscmKFEw40AVzABrMCADuYJq05ce4aDASLESAHQI4wbr3Vwtg4Tj0HuXYgDMYACigBPAA6YQDgUJFNGzADkIHAAVthQgTAAZNHw5n4AhAEwYGIANukxcYH6wFGk8b44AJSsXDCVMMawwGbFVoZcbEA">playground</a>).</p><p>I understand that sometimes (rather rarely though) we really don’t know the keys and the values. Maybe our code shouldn’t even know about them. But think twice before introducing this escape hatch.</p><blockquote><p>Use <code>Result</code> instead of throwing exceptions</p></blockquote><p>The hype around Rust’s Result type is real and it was ported to TS. Let me introduce <a href=https://github.com/vultix/ts-results>ts-results</a> - a wonderful little library that can help with avoiding all the issues associated with the exceptions.</p><p>The main idea is that your function should always return. Your program is in the flow, don’t interrupt it! So instead of this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>divide</span>(<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> { <span style=color:#75715e>// this is an incomplete truth, btw if(b===0){
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Dividing by zero?&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the flow is interrupted, the program doesn&#39;t return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the user should know about it and wrap it in try-catch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// we can sneak in an exception, nobody will notice until it blows up :P
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>/</span><span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; we can use this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MathError</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> { <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;DIVISION_BY_ZERO&#39;</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> { <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;...&#39;</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> { <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;...&#39;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>divide</span>(<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Result</span>&lt;<span style=color:#f92672>number</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>MathError</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Err</span>({ <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;DIVISION_BY_ZERO&#39;</span> })
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Ok</span>(<span style=color:#a6e22e>a</span><span style=color:#f92672>/</span><span style=color:#a6e22e>b</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice how we listed all the errors we could think of and we always return a value from the function. The caller of the function now has clearly defined two paths to follow - <code>Ok&lt;number> | Err&lt;MathError></code>. By the way, you can .map or .mapErr over the Result type and the code results in a beautiful linear <a href=https://fsharpforfunandprofit.com/rop/>railroad</a>.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I wanna wrap it up with ChatGTP-generated Hokku:</p><blockquote><p>In typed code’s embrace,
Errors fade like morning mist,
Maintained with surety.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://ivan-demchenko.github.io/tags/engineering/>engineering</a></li><li><a href=https://ivan-demchenko.github.io/tags/typescript/>typescript</a></li><li><a href=https://ivan-demchenko.github.io/tags/type-systems/>type systems</a></li><li><a href=https://ivan-demchenko.github.io/tags/large-codebase/>large codebase</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ivan-demchenko.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript>var sc_project=12781072,sc_invisible=1,sc_security="4d31877b"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12781072/0/4d31877b/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>