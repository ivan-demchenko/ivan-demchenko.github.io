<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Handle keyboard input in Elm | Ivan's blog</title><meta name=keywords content="elm"><meta name=description content="Often we need to perform certain actions as a feedback to the input from the keyboard. For example, when we need to navigate within a list up and down or perform an action when the meta key (alt or shift) is pressed.
Binding messages to keys The most natural and convenient way to specify which action must be performed when a key is pressed is to use a dictionary. We going to use a list of tuples of key codes plus messages."><meta name=author content><link rel=canonical href=https://ivan-demchenko.github.io/blog/handle-keyboard-input-in-elm/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://ivan-demchenko.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://ivan-demchenko.github.io/static/icon32.png><link rel=apple-touch-icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=mask-icon href=https://ivan-demchenko.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="Handle keyboard input in Elm"><meta property="og:description" content="Often we need to perform certain actions as a feedback to the input from the keyboard. For example, when we need to navigate within a list up and down or perform an action when the meta key (alt or shift) is pressed.
Binding messages to keys The most natural and convenient way to specify which action must be performed when a key is pressed is to use a dictionary. We going to use a list of tuples of key codes plus messages."><meta property="og:type" content="article"><meta property="og:url" content="https://ivan-demchenko.github.io/blog/handle-keyboard-input-in-elm/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-11-24T00:00:00+00:00"><meta property="article:modified_time" content="2017-11-24T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Handle keyboard input in Elm"><meta name=twitter:description content="Often we need to perform certain actions as a feedback to the input from the keyboard. For example, when we need to navigate within a list up and down or perform an action when the meta key (alt or shift) is pressed.
Binding messages to keys The most natural and convenient way to specify which action must be performed when a key is pressed is to use a dictionary. We going to use a list of tuples of key codes plus messages."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ivan-demchenko.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Handle keyboard input in Elm","item":"https://ivan-demchenko.github.io/blog/handle-keyboard-input-in-elm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Handle keyboard input in Elm","name":"Handle keyboard input in Elm","description":"Often we need to perform certain actions as a feedback to the input from the keyboard. For example, when we need to navigate within a list up and down or perform an action when the meta key (alt or shift) is pressed.\nBinding messages to keys The most natural and convenient way to specify which action must be performed when a key is pressed is to use a dictionary. We going to use a list of tuples of key codes plus messages.","keywords":["elm"],"articleBody":"Often we need to perform certain actions as a feedback to the input from the keyboard. For example, when we need to navigate within a list up and down or perform an action when the meta key (alt or shift) is pressed.\nBinding messages to keys The most natural and convenient way to specify which action must be performed when a key is pressed is to use a dictionary. We going to use a list of tuples of key codes plus messages. In the function below the first argument is the default (or fallback) action and the second argument is the mapping of keys to messages:\nonKeyups : m -\u003e List ( Int, m ) -\u003e Attribute m onKeyups fallback keysToMsgs = let msgByKeyCode = \\kc -\u003e Maybe.withDefault fallback \u003c| Dict.get kc \u003c| Dict.fromList keysToMsgs in on \"keyup\" \u003c| Decode.map msgByKeyCode keyCode Here is what is happening. We have a lambda function msgByKeyCode of one argument kc (for key code). Function on takes a string (the event name) and a Decoder msg. The former will decode an event object (untyped, from js) and return a message to trigger.\nWe need to get the code of a key that was pressed. keyCode for the rescue! It returns Decoder Int.\nOkay, We have a list of pairs of ints and messages. If we take that Decoder Int and map it over using a function of type Int -\u003e Msg we will get a Decoder Msg (this is what Functors for). Our lambda function does exactly this! Awesome, we only need to find a corresponding pair in a list! To do so, it is super convenient to use a Dictionary (simply, a key-value storage) as we can easily get from it. What we do here is that we take this list, turn it into a Dict, first item of a tuple becomes a key, the second one becomes a value. Then we can get from that Dict. However, get returns us Maybe x, otherwise, we would have to deal with nulls or undefineds or handle exceptions or something else. There’s no need for it if we have Maybe type. Okay, so at this stage we get Maybe Msg. How do “extract” it from Maybe? Well, one way is to provide a default or fallback value if Nothing has been found. And we have it! It is famous Noop! In other words, if our user pressed a key, and there’s no such pair with the code, we’re not interested in that key, we do nothing!\nIt only looks scary at the beginning and the temptation to come back to JS and run the code and check the error in the console is high. But, from my experience, the good way to approach the problem is to follow the type annotations and think as a compiler. If you know what a given function does, it is no brainer anymore.\nOkay, enough lyrics, let’s use our function:\nul [ onKeyups Noop [ ( 38, MoveSelection Up ), ( 40, MoveSelection Down ) ] ] -- ... Handle meta keys The principle is the same here. However, now we need to send a Message with two booleans. We’re going to send NewItem with the state of Shift and Alt keys:\ntype Msg = NewItem Bool Bool onKeyupsMeta : m -\u003e List ( Int, Bool -\u003e Bool -\u003e m ) -\u003e Attribute m onKeyupsMeta fallback keysToMsgs = let isShift = Decode.field \"shiftKey\" Decode.bool isAlt = Decode.field \"altKey\" Decode.bool msgByKeyCode = \\kc altKey shiftKey -\u003e Maybe.withDefault fallback \u003c| Maybe.map (\\msgFn -\u003e msgFn shiftKey) \u003c| Maybe.map (\\msgFn -\u003e msgFn altKey) \u003c| Dict.get kc \u003c| Dict.fromList keysToMsgs in on \"keyup\" \u003c| Decode.map3 msgByKeyCode keyCode isAlt isShift You can definitely spot familiar parts. The only difference is that we have to use two more decoders for meta keys and map over that Maybe Msg from the dictionary two times. Each map will partially apply NewItem adding info about meta keys. That’s it.\nImportant part to remember here is that Maybe and Decoder are Functors and NewItem is a function of two arguments: NewItem : Bool -\u003e Bool -\u003e Msg. Here it is in action:\ninput [ type_ \"text\" , onKeyupsMeta Noop [ ( 13, NewItem ) ] ] [] Again, the key factor here is that we don’t have access to the event object. Instead we provide a decoder that will translate it into a data structure that Elm can work with.\nI hope you can find it useful for learning and understanding Elm.\n","wordCount":"752","inLanguage":"en","datePublished":"2017-11-24T00:00:00Z","dateModified":"2017-11-24T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivan-demchenko.github.io/blog/handle-keyboard-input-in-elm/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://ivan-demchenko.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ivan-demchenko.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ivan-demchenko.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://ivan-demchenko.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ivan-demchenko.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ivan-demchenko.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li><li><a href=https://ivan-demchenko.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Handle keyboard input in Elm</h1><div class=post-meta><span title='2017-11-24 00:00:00 +0000 UTC'>November 24, 2017</span>&nbsp;·&nbsp;4 min&nbsp;|&nbsp;<a href=https://github.com/ivan-demchenko/ivan-demchenko.github.io/blog/handle-keyboard-input-in-elm.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Often we need to perform certain actions as a feedback to the input from the keyboard. For example, when we need to navigate within a list up and down or perform an action when the meta key (alt or shift) is pressed.</p><h2 id=binding-messages-to-keys>Binding messages to keys<a hidden class=anchor aria-hidden=true href=#binding-messages-to-keys>#</a></h2><p>The most natural and convenient way to specify which action must be performed when a key is pressed is to use a dictionary. We going to use a list of tuples of key codes plus messages. In the function below the first argument is the default (or fallback) action and the second argument is the mapping of keys to messages:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elm data-lang=elm><span style=display:flex><span>onKeyups <span style=color:#a6e22e>:</span> m <span style=color:#a6e22e>-&gt;</span> <span style=color:#66d9ef>List</span> ( <span style=color:#66d9ef>Int</span>, m ) <span style=color:#a6e22e>-&gt;</span> <span style=color:#66d9ef>Attribute</span> m
</span></span><span style=display:flex><span>onKeyups fallback keysToMsgs <span style=color:#a6e22e>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>    msgByKeyCode <span style=color:#a6e22e>=</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>\</span>kc <span style=color:#a6e22e>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>Maybe</span><span style=color:#a6e22e>.</span>withDefault fallback <span style=color:#a6e22e>&lt;|</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>Dict</span><span style=color:#a6e22e>.</span>get kc <span style=color:#a6e22e>&lt;|</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>Dict</span><span style=color:#a6e22e>.</span>fromList keysToMsgs
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    on <span style=color:#e6db74>&#34;keyup&#34;</span> <span style=color:#a6e22e>&lt;|</span> <span style=color:#66d9ef>Decode</span><span style=color:#a6e22e>.</span>map msgByKeyCode keyCode
</span></span></code></pre></div><p>Here is what is happening. We have a lambda function <code>msgByKeyCode</code> of one argument <code>kc</code> (for key code). Function <code>on</code> takes a string (the event name) and a <code>Decoder msg</code>. The former will decode an event object (untyped, from js) and return a message to trigger.</p><p>We need to get the code of a key that was pressed. <code>keyCode</code> for the rescue! It returns <code>Decoder Int</code>.</p><p>Okay, We have a list of pairs of <code>int</code>s and <code>message</code>s. If we take that <code>Decoder Int</code> and map it over using a function of type <code>Int -> Msg</code> we will get a <code>Decoder Msg</code> (this is what <code>Functor</code>s for). Our lambda function does exactly this! Awesome, we only need to find a corresponding pair in a list! To do so, it is super convenient to use a <code>Dictionary</code> (simply, a key-value storage) as we can easily <code>get</code> from it. What we do here is that we take this list, turn it into a Dict, first item of a tuple becomes a key, the second one becomes a value. Then we can <code>get</code> from that Dict. However, <code>get</code> returns us <code>Maybe x</code>, otherwise, we would have to deal with <code>null</code>s or <code>undefined</code>s or handle exceptions or something else. There’s no need for it if we have <code>Maybe</code> type. Okay, so at this stage we get <code>Maybe Msg</code>. How do “extract” it from <code>Maybe</code>? Well, one way is to provide a default or fallback value if <code>Nothing</code> has been found. And we have it! It is famous <code>Noop</code>! In other words, if our user pressed a key, and there’s no such pair with the code, we’re not interested in that key, we do nothing!</p><p>It only looks scary at the beginning and the temptation to come back to JS and run the code and check the error in the console is high. But, from my experience, the good way to approach the problem is to follow the type annotations and think as a compiler. If you know what a given function does, it is no brainer anymore.</p><p>Okay, enough lyrics, let’s use our function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elm data-lang=elm><span style=display:flex><span>ul
</span></span><span style=display:flex><span>  [ onKeyups <span style=color:#66d9ef>Noop</span> [ ( <span style=color:#ae81ff>38</span>, <span style=color:#66d9ef>MoveSelection</span> <span style=color:#66d9ef>Up</span> ), ( <span style=color:#ae81ff>40</span>, <span style=color:#66d9ef>MoveSelection</span> <span style=color:#66d9ef>Down</span> ) ]
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- ...</span>
</span></span></code></pre></div><h2 id=handle-meta-keys>Handle meta keys<a hidden class=anchor aria-hidden=true href=#handle-meta-keys>#</a></h2><p>The principle is the same here. However, now we need to send a Message with two booleans. We’re going to send <code>NewItem</code> with the state of Shift and Alt keys:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elm data-lang=elm><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Msg</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>=</span> <span style=color:#66d9ef>NewItem</span> <span style=color:#66d9ef>Bool</span> <span style=color:#66d9ef>Bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>onKeyupsMeta <span style=color:#a6e22e>:</span> m <span style=color:#a6e22e>-&gt;</span> <span style=color:#66d9ef>List</span> ( <span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Bool</span> <span style=color:#a6e22e>-&gt;</span> <span style=color:#66d9ef>Bool</span> <span style=color:#a6e22e>-&gt;</span> m ) <span style=color:#a6e22e>-&gt;</span> <span style=color:#66d9ef>Attribute</span> m
</span></span><span style=display:flex><span>  onKeyupsMeta fallback keysToMsgs <span style=color:#a6e22e>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>      isShift <span style=color:#a6e22e>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>Decode</span><span style=color:#a6e22e>.</span>field <span style=color:#e6db74>&#34;shiftKey&#34;</span> <span style=color:#66d9ef>Decode</span><span style=color:#a6e22e>.</span>bool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      isAlt <span style=color:#a6e22e>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>Decode</span><span style=color:#a6e22e>.</span>field <span style=color:#e6db74>&#34;altKey&#34;</span> <span style=color:#66d9ef>Decode</span><span style=color:#a6e22e>.</span>bool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      msgByKeyCode <span style=color:#a6e22e>=</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>\</span>kc altKey shiftKey <span style=color:#a6e22e>-&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>Maybe</span><span style=color:#a6e22e>.</span>withDefault fallback <span style=color:#a6e22e>&lt;|</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>Maybe</span><span style=color:#a6e22e>.</span>map (<span style=color:#a6e22e>\</span>msgFn <span style=color:#a6e22e>-&gt;</span> msgFn shiftKey) <span style=color:#a6e22e>&lt;|</span>
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>Maybe</span><span style=color:#a6e22e>.</span>map (<span style=color:#a6e22e>\</span>msgFn <span style=color:#a6e22e>-&gt;</span> msgFn altKey) <span style=color:#a6e22e>&lt;|</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>Dict</span><span style=color:#a6e22e>.</span>get kc <span style=color:#a6e22e>&lt;|</span>
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>Dict</span><span style=color:#a6e22e>.</span>fromList keysToMsgs
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      on <span style=color:#e6db74>&#34;keyup&#34;</span> <span style=color:#a6e22e>&lt;|</span> <span style=color:#66d9ef>Decode</span><span style=color:#a6e22e>.</span>map<span style=color:#ae81ff>3</span> msgByKeyCode keyCode isAlt isShift
</span></span></code></pre></div><p>You can definitely spot familiar parts. The only difference is that we have to use two more decoders for meta keys and map over that <code>Maybe Msg</code> from the dictionary two times. Each map will partially apply <code>NewItem</code> adding info about meta keys. That’s it.</p><p>Important part to remember here is that <code>Maybe</code> and <code>Decoder</code> are <code>Functors</code> and <code>NewItem</code> is a function of two arguments: <code>NewItem : Bool -> Bool -> Msg</code>. Here it is in action:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elm data-lang=elm><span style=display:flex><span>input
</span></span><span style=display:flex><span>  [ type_ <span style=color:#e6db74>&#34;text&#34;</span>
</span></span><span style=display:flex><span>  , onKeyupsMeta <span style=color:#66d9ef>Noop</span> [ ( <span style=color:#ae81ff>13</span>, <span style=color:#66d9ef>NewItem</span> ) ]
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>  []
</span></span></code></pre></div><p>Again, the key factor here is that we don’t have access to the event object. Instead we provide a decoder that will translate it into a data structure that Elm can work with.</p><p>I hope you can find it useful for learning and understanding Elm.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ivan-demchenko.github.io/tags/elm/>elm</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ivan-demchenko.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript>var sc_project=12781072,sc_invisible=1,sc_security="4d31877b"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12781072/0/4d31877b/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>