<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>UI library as a mono-repository. Part 1 | Ivan's blog</title><meta name=keywords content="front-end,architecture"><meta name=description content="Welcome to the first instalment of the series dedicated to the re-architecture of a UI library. I helped my company to transition from the monolithic setup to a mono-repository by leading this project.
This is all very familiar It seems like this is a common topic these days: Deprecate monoliths and move toward micro-frontend/micro-service architecture.
However, many UI libraries start as a monolith. Meaning, there&rsquo;s a single distribution for the whole library."><meta name=author content><link rel=canonical href=https://raqystyle.github.io/blog/ui-lib-monorepo-part1/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raqystyle.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://raqystyle.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://raqystyle.github.io/static/icon32.png><link rel=apple-touch-icon href=https://raqystyle.github.io/static/icon.png><link rel=mask-icon href=https://raqystyle.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6GQB09KH8K"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6GQB09KH8K")</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-58254906-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-58254906-1")</script><meta property="og:title" content="UI library as a mono-repository. Part 1"><meta property="og:description" content="Welcome to the first instalment of the series dedicated to the re-architecture of a UI library. I helped my company to transition from the monolithic setup to a mono-repository by leading this project.
This is all very familiar It seems like this is a common topic these days: Deprecate monoliths and move toward micro-frontend/micro-service architecture.
However, many UI libraries start as a monolith. Meaning, there&rsquo;s a single distribution for the whole library."><meta property="og:type" content="article"><meta property="og:url" content="https://raqystyle.github.io/blog/ui-lib-monorepo-part1/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-10-25T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="UI library as a mono-repository. Part 1"><meta name=twitter:description content="Welcome to the first instalment of the series dedicated to the re-architecture of a UI library. I helped my company to transition from the monolithic setup to a mono-repository by leading this project.
This is all very familiar It seems like this is a common topic these days: Deprecate monoliths and move toward micro-frontend/micro-service architecture.
However, many UI libraries start as a monolith. Meaning, there&rsquo;s a single distribution for the whole library."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://raqystyle.github.io/blog/"},{"@type":"ListItem","position":2,"name":"UI library as a mono-repository. Part 1","item":"https://raqystyle.github.io/blog/ui-lib-monorepo-part1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UI library as a mono-repository. Part 1","name":"UI library as a mono-repository. Part 1","description":"Welcome to the first instalment of the series dedicated to the re-architecture of a UI library. I helped my company to transition from the monolithic setup to a mono-repository by leading this project.\nThis is all very familiar It seems like this is a common topic these days: Deprecate monoliths and move toward micro-frontend/micro-service architecture.\nHowever, many UI libraries start as a monolith. Meaning, there\u0026rsquo;s a single distribution for the whole library.","keywords":["front-end","architecture"],"articleBody":"Welcome to the first instalment of the series dedicated to the re-architecture of a UI library. I helped my company to transition from the monolithic setup to a mono-repository by leading this project.\nThis is all very familiar It seems like this is a common topic these days: Deprecate monoliths and move toward micro-frontend/micro-service architecture.\nHowever, many UI libraries start as a monolith. Meaning, thereâ€™s a single distribution for the whole library. This setup can function for quite some time. However, it has a few important drawbacks:\nit does not provide the autonomy to work on an individual UI component and distribute only that component; the only way to release is to release the entire UI library; Why is that a problem? Letâ€™s consider a few scenarios. You work in an organisation with many teams who work on a product. Teamsâ€™ autonomy is one of the factors that make modern organisations move faster. However, a shared among the teams UI library may act as a glue reducing the autonomy.\nNow, imagine there was a bug fix in one of the components. In the meantime, somebody else changed the API of another component. This sounds like a good set of changes to be released. However, if we do it, a person waiting for the bug fix will also need to change all the places in their code where that other component is used. Again, autonomy is reduced.\nIf we zoom out a bit, weâ€™ll see that the bigger the changeset, the greater the effort required to adopt a new version of the UI library. This strategy reduces the adoption rate and makes the end product look fragmented as not all teams can catch up. Besides, consumers (other teams in your organisation) depend on the release schedule. Can we improve this?\nWhatâ€™s the solution? One way to solve the problems I mentioned above is to break this monolith into pieces. Instead of a single NPM package that contains all the UI components, we deliver an NPM package per UI component:\nThe tooling these days allows a great deal of automation. Therefore, the whole release and version management cycle can be completely automated. In our particular case, we used:\nLerna with Yarn workspaces TypeScript Commitizen, Conventional Commits and Commitlint Rollup Storybook Hygen ESLint, Prettier, Husky, StyleLint Picking a name It may seem unimportant, but a good name enables lots of good things: NPM namespace, Confluence space, slack channels, internal branding, to name a few.\nOur library is called â€œHighlight UIâ€. It wasnâ€™t easy to come up with a good name, but after a few trials, we managed.\nDirectory structure Our project now looks like this (somewhat simplified view):\nui-library/ â”œâ”€â”€ğŸ“ node_modules/ â”œâ”€â”€ğŸ“ packages/ | â”œâ”€â”€ğŸ“ config/ | | â”œâ”€â”€ğŸ“ base-typescript/ | | â”œâ”€â”€ğŸ“ base-jest/ | | â””â”€â”€ğŸ“ scripts/ | â””â”€â”€ğŸ“ ui/ | â”œâ”€â”€ğŸ“ checkbox/ | â”œâ”€â”€ğŸ“ button/ | \u003c...\u003e â”œâ”€â”€ğŸ“ package.json â”œâ”€â”€ğŸ“ tsconfig.json There are two workspaces: config and ui. This leaves the potential to add more workspaces to separate things logically.\nNotice, there are base-typescript and base-jest configuration packages. Any other tsconfig.json or jest.config.js extends the configs from those packages. Finally, there is a package with some scripts that contains build/cleanup/storybook runner/etc tools. Very handle to encapsulate a lot of build dependencies and provide meaningful defaults and upgrade strategy.\nStructure of the package Each package looks like a normal NPM package:\nğŸ“ ui-library/packages/ui/button/ â”œâ”€â”€ğŸ“ build/ | â”œâ”€â”€ğŸ“ build.es5.json | â””â”€â”€ğŸ“ build.es2015.json â”œâ”€â”€ğŸ“ node_modules/ â”œâ”€â”€ğŸ“ src/ â”œâ”€â”€ğŸ“ tests/ â”œâ”€â”€ğŸ“ stories/ â”œâ”€â”€ğŸ“ index.tsx â”œâ”€â”€ğŸ“ tsconfig.json â”œâ”€â”€ğŸ“ package.json â”œâ”€â”€ğŸ“ README.md â””â”€â”€ğŸ“ CHANGELOG.md In our stories, we decided to import from the index.tsx file. This way, we can control what kind of interface a package exposes. We use a similar recommendation for tests, but it is not as strict.\nA typical package.json file will look something like this:\n{ \"name\": \"@highlight-ui/button\", \"version\": \"8.0.1\", \"main\": \"dist/cjs/index.js\", \"module\": \"dist/esm/index.js\", \"types\": \"dist/cjs/index.d.ts\", \"style\": \"dist/index.css\", \"files\": [\"dist\"], \"scripts\": { \"test\": \"jest\", \"clean\": \"highlight-cleanup\", \"build\": \"highlight-build\", \"sb:dev\": \"highlight-storybook\" }, \"dependencies\": { \"@highlight-ui/icon\": \"^3.0.17\" // ... }, \"devDependencies\": { \"classnames\": \"^2.3.1\", \"react\": \"^17.0.0\" //... }, \"peerDependencies\": { \"classnames\": \"^2.3.1\", \"react\": \"^17.0.0\" } } Nothing groundbreaking. But notice how 3rd party dependencies are treated. We can ask consumers to install specific versions of react and classnames.\nHow to consume it? Treat every package as a 3rd party. Simply install the individual packages:\nyarn add @highlight-ui/button This way, the consumer will only install a collection of packages, each containing one and only UI component, that they need. Unless one or more packages added as dependencies are â€œheavyâ€œ (with a â€œheavyâ€ external dependency, in KB), the impact on the total bundle size of an app is going to be only a fraction of all dependencies.\nVersioning and releases A version for each package is calculated automatically thanks to semantic-release. This can be achieved on CI based on the commit messages (Conventional commits + Commitizen) or a special file (depending on tooling).\nDeprecation In general, as practice shows, just releasing a new version suffice.\nHowever, NPM has a special command to deprecate packages and version(s). This process can be automated using CI. What is needed is a special job that will run only when thereâ€™s a special file with packages, versions and deprecation message. After the deprecation is done, CI can clean up this file.\nAdding a new component to the library A new package can be scaffolded using a template. We use Hygen - works very well and helps contributors to start a new package with almost no guidance.\nDependencies between packages Some packages are going to depend on each other and thatâ€™s okay.\nFor example, almost every UI-related package will depend on the theme or utils.\nTools like Lerna can help automating versioning. We use commitizen and conventional commits to write commit messages in a specific format that can be parsed by Lerna to determine the next version of the changed packaged.\nApart from writing code, this is the only thing the other engineers need to think about. The rest is automated.\nFor example, a pagination@0.3.1 depends on the button@0.1.14. Now, due to a new feature, the Button becomes 0.2.0. In this case, pagination gets a patch 0.3.1 -\u003e 0.3.2 and the version of the Button in its package.json.\nAutonomy Each package is autonomous and can be released separately. The shared parts (utils, theme, etc.) are as thing/small as possible and change rarely.\nRoom for experimentation When each package is isolated, this allows contributors to experiments with tooling and approaches without affecting the whole library. For example, one package can be built using rollup, another can be built using webpack.\nConclusion Thank you making this far! I hope you found it useful. I would like to invite to the Part 2: handing CSS dependencies\n","wordCount":"1120","inLanguage":"en","datePublished":"2021-10-25T00:00:00Z","dateModified":"2021-10-25T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://raqystyle.github.io/blog/ui-lib-monorepo-part1/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://raqystyle.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://raqystyle.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://raqystyle.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://raqystyle.github.io/about/ title=About><span>About</span></a></li><li><a href=https://raqystyle.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://raqystyle.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li><li><a href=https://raqystyle.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>UI library as a mono-repository. Part 1</h1><div class=post-meta><span title='2021-10-25 00:00:00 +0000 UTC'>October 25, 2021</span>&nbsp;Â·&nbsp;6 min&nbsp;|&nbsp;<a href=https://github.com/raqystyle/raqystyle.github.io/content/blog/ui-lib-monorepo-part1/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Welcome to the first instalment of the series dedicated to the re-architecture of a UI library. I helped my company to transition from the monolithic setup to a mono-repository by leading this project.</p><h2 id=this-is-all-very-familiar>This is all very familiar<a hidden class=anchor aria-hidden=true href=#this-is-all-very-familiar>#</a></h2><p>It seems like this is a common topic these days: Deprecate monoliths and move toward micro-frontend/micro-service architecture.</p><p>However, many UI libraries start as a monolith. Meaning, there&rsquo;s a single distribution for the whole library. This setup can function for quite some time. However, it has a few important drawbacks:</p><ul><li>it does not provide the autonomy to work on an individual UI component and distribute only that component;</li><li>the only way to release is to release the entire UI library;</li></ul><h2 id=why-is-that-a-problem>Why is that a problem?<a hidden class=anchor aria-hidden=true href=#why-is-that-a-problem>#</a></h2><p>Let&rsquo;s consider a few scenarios. You work in an organisation with many teams who work on a product. Teams&rsquo; autonomy is one of the factors that make modern organisations move faster. However, a shared among the teams UI library may act as a glue reducing the autonomy.</p><p>Now, imagine there was a bug fix in one of the components. In the meantime, somebody else changed the API of another component. This sounds like a good set of changes to be released. However, if we do it, a person waiting for the bug fix will also need to change all the places in their code where that other component is used. Again, autonomy is reduced.</p><p>If we zoom out a bit, we&rsquo;ll see that the bigger the changeset, the greater the effort required to adopt a new version of the UI library. This strategy reduces the adoption rate and makes the end product look fragmented as not all teams can catch up. Besides, consumers (other teams in your organisation) depend on the release schedule. Can we improve this?</p><h2 id=whats-the-solution>What&rsquo;s the solution?<a hidden class=anchor aria-hidden=true href=#whats-the-solution>#</a></h2><p>One way to solve the problems I mentioned above is to break this monolith into pieces. Instead of a single NPM package that contains all the UI components, we deliver an NPM package per UI component:</p><p><img loading=lazy src=./ui-lib-monorepo-p1/p1.png alt="Monolith turns into a set of packages"></p><p>The tooling these days allows a great deal of automation. Therefore, the whole release and version management cycle can be completely automated. In our particular case, we used:</p><ul><li>Lerna with Yarn workspaces</li><li>TypeScript</li><li>Commitizen, Conventional Commits and Commitlint</li><li>Rollup</li><li>Storybook</li><li>Hygen</li><li>ESLint, Prettier, Husky, StyleLint</li></ul><h3 id=picking-a-name>Picking a name<a hidden class=anchor aria-hidden=true href=#picking-a-name>#</a></h3><p>It may seem unimportant, but a good name enables lots of good things: NPM namespace, Confluence space, slack channels, internal branding, to name a few.</p><p>Our library is called &ldquo;Highlight UI&rdquo;. It wasn&rsquo;t easy to come up with a good name, but after a few trials, we managed.</p><h3 id=directory-structure>Directory structure<a hidden class=anchor aria-hidden=true href=#directory-structure>#</a></h3><p>Our project now looks like this (somewhat simplified view):</p><pre tabindex=0><code>ui-library/
â”œâ”€â”€ğŸ“ node_modules/
â”œâ”€â”€ğŸ“ packages/
|   â”œâ”€â”€ğŸ“ config/
|   |   â”œâ”€â”€ğŸ“ base-typescript/
|   |   â”œâ”€â”€ğŸ“ base-jest/
|   |   â””â”€â”€ğŸ“ scripts/
|   â””â”€â”€ğŸ“ ui/
|       â”œâ”€â”€ğŸ“ checkbox/
|       â”œâ”€â”€ğŸ“ button/
|     &lt;...&gt;
â”œâ”€â”€ğŸ“ package.json
â”œâ”€â”€ğŸ“ tsconfig.json
</code></pre><p>There are two workspaces: <code>config</code> and <code>ui</code>. This leaves the potential to add more workspaces to separate things logically.</p><p>Notice, there are <code>base-typescript</code> and <code>base-jest</code> configuration packages. Any other <code>tsconfig.json</code> or <code>jest.config.js</code> extends the configs from those packages. Finally, there is a package with some <code>scripts</code> that contains build/cleanup/storybook runner/etc tools. Very handle to encapsulate a lot of build dependencies and provide meaningful defaults and upgrade strategy.</p><h3 id=structure-of-the-package>Structure of the package<a hidden class=anchor aria-hidden=true href=#structure-of-the-package>#</a></h3><p>Each package looks like a normal NPM package:</p><pre tabindex=0><code>ğŸ“ ui-library/packages/ui/button/
â”œâ”€â”€ğŸ“ build/
|  â”œâ”€â”€ğŸ“ build.es5.json
|  â””â”€â”€ğŸ“ build.es2015.json
â”œâ”€â”€ğŸ“ node_modules/
â”œâ”€â”€ğŸ“ src/
â”œâ”€â”€ğŸ“ tests/
â”œâ”€â”€ğŸ“ stories/
â”œâ”€â”€ğŸ“ index.tsx
â”œâ”€â”€ğŸ“ tsconfig.json
â”œâ”€â”€ğŸ“ package.json
â”œâ”€â”€ğŸ“ README.md
â””â”€â”€ğŸ“ CHANGELOG.md
</code></pre><p>In our stories, we decided to import from the <code>index.tsx</code> file. This way, we can control what kind of interface a package exposes. We use a similar recommendation for tests, but it is not as strict.</p><p>A typical package.json file will look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;@highlight-ui/button&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;version&#34;</span>: <span style=color:#e6db74>&#34;8.0.1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;main&#34;</span>: <span style=color:#e6db74>&#34;dist/cjs/index.js&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;module&#34;</span>: <span style=color:#e6db74>&#34;dist/esm/index.js&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;types&#34;</span>: <span style=color:#e6db74>&#34;dist/cjs/index.d.ts&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;style&#34;</span>: <span style=color:#e6db74>&#34;dist/index.css&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;files&#34;</span>: [<span style=color:#e6db74>&#34;dist&#34;</span>],
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;scripts&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;test&#34;</span>: <span style=color:#e6db74>&#34;jest&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;clean&#34;</span>: <span style=color:#e6db74>&#34;highlight-cleanup&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;build&#34;</span>: <span style=color:#e6db74>&#34;highlight-build&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;sb:dev&#34;</span>: <span style=color:#e6db74>&#34;highlight-storybook&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;dependencies&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;@highlight-ui/icon&#34;</span>: <span style=color:#e6db74>&#34;^3.0.17&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;devDependencies&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;classnames&#34;</span>: <span style=color:#e6db74>&#34;^2.3.1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;react&#34;</span>: <span style=color:#e6db74>&#34;^17.0.0&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;peerDependencies&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;classnames&#34;</span>: <span style=color:#e6db74>&#34;^2.3.1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;react&#34;</span>: <span style=color:#e6db74>&#34;^17.0.0&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nothing groundbreaking. But notice how 3rd party dependencies are treated. We can ask consumers to install specific versions of <code>react</code> and <code>classnames</code>.</p><h2 id=how-to-consume-it>How to consume it?<a hidden class=anchor aria-hidden=true href=#how-to-consume-it>#</a></h2><p>Treat every package as a 3rd party. Simply install the individual packages:</p><pre tabindex=0><code>yarn add @highlight-ui/button
</code></pre><p>This way, the consumer will only install a collection of packages, each containing one and only UI component, that they need. Unless one or more packages added as dependencies are â€œheavyâ€œ (with a â€œheavyâ€ external dependency, in KB), the impact on the total bundle size of an app is going to be only a fraction of all dependencies.</p><h2 id=versioning-and-releases>Versioning and releases<a hidden class=anchor aria-hidden=true href=#versioning-and-releases>#</a></h2><p>A version for each package is calculated automatically thanks to semantic-release. This can be achieved on CI based on the commit messages (Conventional commits + Commitizen) or a special file (depending on tooling).</p><h2 id=deprecation>Deprecation<a hidden class=anchor aria-hidden=true href=#deprecation>#</a></h2><p>In general, as practice shows, just releasing a new version suffice.</p><p>However, NPM has a special command to deprecate packages and version(s). This process can be automated using CI. What is needed is a special job that will run only when there&rsquo;s a special file with packages, versions and deprecation message. After the deprecation is done, CI can clean up this file.</p><h2 id=adding-a-new-component-to-the-library>Adding a new component to the library<a hidden class=anchor aria-hidden=true href=#adding-a-new-component-to-the-library>#</a></h2><p>A new package can be scaffolded using a template. We use <code>Hygen</code> - works very well and helps contributors to start a new package with almost no guidance.</p><h2 id=dependencies-between-packages>Dependencies between packages<a hidden class=anchor aria-hidden=true href=#dependencies-between-packages>#</a></h2><p>Some packages are going to depend on each other and thatâ€™s okay.</p><p>For example, almost every UI-related package will depend on the <code>theme</code> or <code>utils</code>.</p><p>Tools like <code>Lerna</code> can help automating versioning. We use <code>commitizen</code> and <code>conventional commits</code> to write commit messages in a specific format that can be parsed by Lerna to determine the next version of the changed packaged.</p><p>Apart from writing code, this is the only thing the other engineers need to think about. The rest is automated.</p><p>For example, a <code>pagination@0.3.1</code> depends on the <code>button@0.1.14</code>. Now, due to a new feature, the Button becomes <code>0.2.0</code>. In this case, pagination gets a patch <code>0.3.1 -> 0.3.2</code> and the version of the Button in its <code>package.json</code>.</p><h2 id=autonomy>Autonomy<a hidden class=anchor aria-hidden=true href=#autonomy>#</a></h2><p>Each package is autonomous and can be released separately. The shared parts (<code>utils</code>, <code>theme</code>, etc.) are as thing/small as possible and change rarely.</p><h2 id=room-for-experimentation>Room for experimentation<a hidden class=anchor aria-hidden=true href=#room-for-experimentation>#</a></h2><p>When each package is isolated, this allows contributors to experiments with tooling and approaches without affecting the whole library. For example, one package can be built using rollup, another can be built using webpack.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Thank you making this far! I hope you found it useful. I would like to invite to <a href=/ui-lib-monorepo-part2/>the Part 2: handing CSS dependencies</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://raqystyle.github.io/tags/front-end/>front-end</a></li><li><a href=https://raqystyle.github.io/tags/architecture/>architecture</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://raqystyle.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>