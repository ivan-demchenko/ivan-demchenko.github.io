<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interfaces, good and bad | Ivan's blog</title><meta name=keywords content="oop,design,architecture"><meta name=description content="Designing applications can be a challenging task. Over the course of my career, I have developed a few guiding principles that I would like to share with you. These are more food for thought, rather than hard rules to follow.
Throughout this article, I use adjectives like &ldquo;good&rdquo; and &ldquo;bad&rdquo; - purely subjectively.
Why do we need interfaces? Public interfaces provide an overview of the capabilities of the module. If an interface and its methods have descriptive names (defined later), that interface can be a valuable addition to the documentation."><meta name=author content><link rel=canonical href=https://ivan-demchenko.github.io/blog/interfaces-good-bad/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://ivan-demchenko.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://ivan-demchenko.github.io/static/icon32.png><link rel=apple-touch-icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=mask-icon href=https://ivan-demchenko.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="Interfaces, good and bad"><meta property="og:description" content="Designing applications can be a challenging task. Over the course of my career, I have developed a few guiding principles that I would like to share with you. These are more food for thought, rather than hard rules to follow.
Throughout this article, I use adjectives like &ldquo;good&rdquo; and &ldquo;bad&rdquo; - purely subjectively.
Why do we need interfaces? Public interfaces provide an overview of the capabilities of the module. If an interface and its methods have descriptive names (defined later), that interface can be a valuable addition to the documentation."><meta property="og:type" content="article"><meta property="og:url" content="https://ivan-demchenko.github.io/blog/interfaces-good-bad/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-03-11T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Interfaces, good and bad"><meta name=twitter:description content="Designing applications can be a challenging task. Over the course of my career, I have developed a few guiding principles that I would like to share with you. These are more food for thought, rather than hard rules to follow.
Throughout this article, I use adjectives like &ldquo;good&rdquo; and &ldquo;bad&rdquo; - purely subjectively.
Why do we need interfaces? Public interfaces provide an overview of the capabilities of the module. If an interface and its methods have descriptive names (defined later), that interface can be a valuable addition to the documentation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ivan-demchenko.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Interfaces, good and bad","item":"https://ivan-demchenko.github.io/blog/interfaces-good-bad/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Interfaces, good and bad","name":"Interfaces, good and bad","description":"Designing applications can be a challenging task. Over the course of my career, I have developed a few guiding principles that I would like to share with you. These are more food for thought, rather than hard rules to follow.\nThroughout this article, I use adjectives like \u0026ldquo;good\u0026rdquo; and \u0026ldquo;bad\u0026rdquo; - purely subjectively.\nWhy do we need interfaces? Public interfaces provide an overview of the capabilities of the module. If an interface and its methods have descriptive names (defined later), that interface can be a valuable addition to the documentation.","keywords":["oop","design","architecture"],"articleBody":"Designing applications can be a challenging task. Over the course of my career, I have developed a few guiding principles that I would like to share with you. These are more food for thought, rather than hard rules to follow.\nThroughout this article, I use adjectives like “good” and “bad” - purely subjectively.\nWhy do we need interfaces? Public interfaces provide an overview of the capabilities of the module. If an interface and its methods have descriptive names (defined later), that interface can be a valuable addition to the documentation. People often talk about tests as documentation. In my opinion, tests document behaviour, while interfaces describe capabilities.\nWell-defined interfaces help to separate the core logic of the application (the “why”) from the frameworks (the “how”), also known as the “separation of concerns” principle.\nFurthermore, an interface is a contract between the user and the implementation. Given a certain input, we should expect a certain output. The interface can also inform about possible side effects too. Although I believe that a type system can communicate and enforce handing side effects better than documentation.\nFinally, there is another, rather subtle benefit to using interfaces. In essence, an interface is an API that our users can rely on. So users can think of the module and the team behind that API as a 3rd-party. Drawing such a boundary between the units of an organisation and the APIs they maintain is a way to manage the structure and the dependencies between teams. This way, we can answer questions like why this team exists and what value it provides.\nInterfaces and the ubiquitous language I believe that interfaces should use the Ubiquitous Language or the language of business logic and values. This way, we can effectively hide the implementation details and convey the intent of a method.\nGood and bad interfaces As John Ousterhout mentioned in “A Philosophy of Software Design” (and his presentation at Google): narrow and deep interfaces always trump wide and shallow ones. As an example, the author used the UNIX file I/O interface. Statements like this are always a subject of debate. Nevertheless, there is some truth to his words.\nSo, how about shallow and narrow? I would argue that most of the time, such interfaces act only as wrappers around some existing functionality and are not very useful. In fact, such interfaces can be dangerous as developers may use them for mocking (reference)\nBad interfaces inform the users how things work. For example, postMessage or saveData.\nGood interfaces hide those implementation details and convey the intent instead. For example, initiateLoginProcedure or storeAccountData.\nBetter testing Good interfaces can help test behaviour without having to worry about implementation details. Having well-defined, high-level interfaces allows for safer mocking. For example, say we are working on a React app with a login button. The only thing our tests need to check is that the login button has the correct intent. So we can safely mock the actual implementation of the service and check that the correct method has been called. However, we will need a different set of tests for a concrete implementation of this interface. Such testing would help us identify the problematic place sooner than, say, end-to-end tests. Why? Because there would be a test suit for a concrete implementation of an interface that is used in production code.\nExamples I would like to present a few examples of good interfaces (again, subjectively).\nAbstraction over storage Instead of having an interface with methods like get, set and remove, create an interface with methods like saveUserAccount, getAccountData or deleteAccountData. These methods describe the steps of the business processes in your domain, but do not expose any implementation details. A snippet of code using such methods reads more like plain English.\nAbstractions over events Sometimes, we have to deal with an inherently event-driven system. For example, extensions for VSCode are command-based. Therefore, instead of creating a service that exposes the implementation details (like postMessage or executeCommand), you’d better climb one level up and create an API for dealing with the business rules and values. For example, instead of this\ninterface ExtensionService { postMessageToExtension(): Promise\u003cvoid\u003e onMessageFromExtension(callback): Promise\u003cvoid\u003e } … create an interface that conveys the intents:\ninterface ExtensionService { initiateLogin(): Promise\u003cvoid\u003e whenLoginSucceeded(callback): Promise\u003cvoid\u003e } It doesn’t matter how we initiate a login procedure, what matter is the fact that we did it. Mocking such an interface in the UI tests is safe and gives enough confidence that the right CTAs trigger the correct procedures. Yet, we don’t care about the implementation details of that UI.\nConclusion In this article I described my observations and conclusions. These will no doubt be refined in the future. Obviously, the main reason for writing code is to program a computer to perform actions that we need to achieve our goals. The APIs that are based on the domain and the Ubiquitous Language help us to create robust and reliable software, while keeping it “soft” and flexible.\n","wordCount":"827","inLanguage":"en","datePublished":"2023-03-11T00:00:00Z","dateModified":"2023-03-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivan-demchenko.github.io/blog/interfaces-good-bad/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://ivan-demchenko.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ivan-demchenko.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ivan-demchenko.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://ivan-demchenko.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ivan-demchenko.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ivan-demchenko.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Interfaces, good and bad</h1><div class=post-meta><span title='2023-03-11 00:00:00 +0000 UTC'>March 11, 2023</span>&nbsp;·&nbsp;4 min&nbsp;|&nbsp;<a href=https://github.com/ivan-demchenko/ivan-demchenko.github.io/blog/2023-03-11-interfaces-good-bad.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Designing applications can be a challenging task. Over the course of my career, I have developed a few guiding principles that I would like to share with you. These are more food for thought, rather than hard rules to follow.</p><p>Throughout this article, I use adjectives like &ldquo;good&rdquo; and &ldquo;bad&rdquo; - purely subjectively.</p><h2 id=why-do-we-need-interfaces>Why do we need interfaces?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-interfaces>#</a></h2><p>Public interfaces provide an overview of the capabilities of the module. If an interface and its methods have descriptive names (defined later), that interface can be a valuable addition to the documentation. People often talk about tests as documentation. In my opinion, tests document behaviour, while interfaces describe capabilities.</p><p>Well-defined interfaces help to separate the core logic of the application (the &ldquo;why&rdquo;) from the frameworks (the &ldquo;how&rdquo;), also known as the &ldquo;separation of concerns&rdquo; principle.</p><p>Furthermore, an interface is a contract between the user and the implementation. Given a certain input, we should expect a certain output. The interface can also inform about possible side effects too. Although I believe that a type system can communicate and enforce handing side effects better than documentation.</p><p>Finally, there is another, rather subtle benefit to using interfaces. In essence, an interface is an API that our users can rely on. So users can think of the module and the team behind that API as a 3rd-party. Drawing such a boundary between the units of an organisation and the APIs they maintain is a way to manage the structure and the dependencies between teams. This way, we can answer questions like why this team exists and what value it provides.</p><h2 id=interfaces-and-the-ubiquitous-language>Interfaces and the ubiquitous language<a hidden class=anchor aria-hidden=true href=#interfaces-and-the-ubiquitous-language>#</a></h2><p>I believe that interfaces should use the Ubiquitous Language or the language of business logic and values. This way, we can effectively hide the implementation details and convey the intent of a method.</p><h2 id=good-and-bad-interfaces>Good and bad interfaces<a hidden class=anchor aria-hidden=true href=#good-and-bad-interfaces>#</a></h2><p>As John Ousterhout mentioned in &ldquo;A Philosophy of Software Design&rdquo; (and his <a href="https://www.youtube.com/watch?v=bmSAYlu0NcY&t=2779s">presentation at Google</a>): narrow and deep interfaces always trump wide and shallow ones. As an example, the author used the UNIX file I/O interface. Statements like this are always a subject of debate. Nevertheless, there is some truth to his words.</p><p>So, how about shallow and narrow? I would argue that most of the time, such interfaces act only as wrappers around some existing functionality and are not very useful. In fact, such interfaces can be dangerous as developers may use them for mocking (<a href=https://torvo.com.au/articles/why-mocks-are-considered-harmful>reference</a>)</p><p>Bad interfaces inform the users how things work. For example, <code>postMessage</code> or <code>saveData</code>.</p><p>Good interfaces hide those implementation details and convey the intent instead. For example, <code>initiateLoginProcedure</code> or <code>storeAccountData</code>.</p><h2 id=better-testing>Better testing<a hidden class=anchor aria-hidden=true href=#better-testing>#</a></h2><p>Good interfaces can help test behaviour without having to worry about implementation details. Having well-defined, high-level interfaces allows for safer mocking. For example, say we are working on a React app with a login button. The only thing our tests need to check is that the login button has the correct intent. So we can safely mock the actual implementation of the service and check that the correct method has been called. However, we will need a different set of tests for a concrete implementation of this interface. Such testing would help us identify the problematic place sooner than, say, end-to-end tests. Why? Because there would be a test suit for a concrete implementation of an interface that is used in production code.</p><h2 id=examples>Examples<a hidden class=anchor aria-hidden=true href=#examples>#</a></h2><p>I would like to present a few examples of good interfaces (again, subjectively).</p><h3 id=abstraction-over-storage>Abstraction over storage<a hidden class=anchor aria-hidden=true href=#abstraction-over-storage>#</a></h3><p>Instead of having an interface with methods like <code>get</code>, <code>set</code> and <code>remove</code>, create an interface with methods like <code>saveUserAccount</code>, <code>getAccountData</code> or <code>deleteAccountData</code>. These methods describe the steps of the business processes in your domain, but do not expose any implementation details. A snippet of code using such methods reads more like plain English.</p><h3 id=abstractions-over-events>Abstractions over events<a hidden class=anchor aria-hidden=true href=#abstractions-over-events>#</a></h3><p>Sometimes, we have to deal with an inherently event-driven system. For example, extensions for VSCode are command-based. Therefore, instead of creating a service that exposes the implementation details (like <code>postMessage</code> or <code>executeCommand</code>), you&rsquo;d better climb one level up and create an API for dealing with the business rules and values. For example, instead of this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ExtensionService</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>postMessageToExtension</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>onMessageFromExtension</span>(<span style=color:#a6e22e>callback</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; create an interface that conveys the intents:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ExtensionService</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>initiateLogin</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>whenLoginSucceeded</span>(<span style=color:#a6e22e>callback</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It doesn&rsquo;t matter how we initiate a login procedure, what matter is the fact that we did it. Mocking such an interface in the UI tests is safe and gives enough confidence that the right CTAs trigger the correct procedures. Yet, we don&rsquo;t care about the implementation details of that UI.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In this article I described my observations and conclusions. These will no doubt be refined in the future. Obviously, the main reason for writing code is to program a computer to perform actions that we need to achieve our goals. The APIs that are based on the domain and the Ubiquitous Language help us to create robust and reliable software, while keeping it &ldquo;soft&rdquo; and flexible.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ivan-demchenko.github.io/tags/oop/>oop</a></li><li><a href=https://ivan-demchenko.github.io/tags/design/>design</a></li><li><a href=https://ivan-demchenko.github.io/tags/architecture/>architecture</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ivan-demchenko.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript>var sc_project=12781072,sc_invisible=1,sc_security="4d31877b"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12781072/0/4d31877b/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>