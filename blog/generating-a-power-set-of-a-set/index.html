<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generating a power set of a set | Ivan's blog</title><meta name=keywords content="algorithms"><meta name=description content="There&rsquo;s a class of problems that deal with subsets, permutations and so on. Let&rsquo;s find a way to generate a power set of a set with distinct elements. This is a problem #78 on LeetCode.
What is backtracking? According to Wikipedia, backtracking is a general algorithm (or an idea) of searching all the solutions by reducing the search space. It&rsquo;s really close to brute force, try all the options. But at some point we need to take a step back (backtrack) if we cannot proceed."><meta name=author content><link rel=canonical href=https://raqystyle.github.io/blog/generating-a-power-set-of-a-set/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raqystyle.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://raqystyle.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://raqystyle.github.io/static/icon32.png><link rel=apple-touch-icon href=https://raqystyle.github.io/static/icon.png><link rel=mask-icon href=https://raqystyle.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="Generating a power set of a set"><meta property="og:description" content="There&rsquo;s a class of problems that deal with subsets, permutations and so on. Let&rsquo;s find a way to generate a power set of a set with distinct elements. This is a problem #78 on LeetCode.
What is backtracking? According to Wikipedia, backtracking is a general algorithm (or an idea) of searching all the solutions by reducing the search space. It&rsquo;s really close to brute force, try all the options. But at some point we need to take a step back (backtrack) if we cannot proceed."><meta property="og:type" content="article"><meta property="og:url" content="https://raqystyle.github.io/blog/generating-a-power-set-of-a-set/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-09-01T00:00:00+00:00"><meta property="article:modified_time" content="2021-09-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Generating a power set of a set"><meta name=twitter:description content="There&rsquo;s a class of problems that deal with subsets, permutations and so on. Let&rsquo;s find a way to generate a power set of a set with distinct elements. This is a problem #78 on LeetCode.
What is backtracking? According to Wikipedia, backtracking is a general algorithm (or an idea) of searching all the solutions by reducing the search space. It&rsquo;s really close to brute force, try all the options. But at some point we need to take a step back (backtrack) if we cannot proceed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://raqystyle.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Generating a power set of a set","item":"https://raqystyle.github.io/blog/generating-a-power-set-of-a-set/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generating a power set of a set","name":"Generating a power set of a set","description":"There\u0026rsquo;s a class of problems that deal with subsets, permutations and so on. Let\u0026rsquo;s find a way to generate a power set of a set with distinct elements. This is a problem #78 on LeetCode.\nWhat is backtracking? According to Wikipedia, backtracking is a general algorithm (or an idea) of searching all the solutions by reducing the search space. It\u0026rsquo;s really close to brute force, try all the options. But at some point we need to take a step back (backtrack) if we cannot proceed.","keywords":["algorithms"],"articleBody":"There’s a class of problems that deal with subsets, permutations and so on. Let’s find a way to generate a power set of a set with distinct elements. This is a problem #78 on LeetCode.\nWhat is backtracking? According to Wikipedia, backtracking is a general algorithm (or an idea) of searching all the solutions by reducing the search space. It’s really close to brute force, try all the options. But at some point we need to take a step back (backtrack) if we cannot proceed.\nSome classical problems that can be solved by the backtracking are:\nN-queens problem Sudoku Solver Knapsack Problem Generating Permutations So, back to the power sets So, the task is, given a set, find the power set of that set:\nInput: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] I once stumbled upon the following snippet:\nsearch(int k) { if (k == n) { res.push(subset) } else { search(k+1); subset.push(k); search(k+1); subset.pop(); } } This piece of code relies heavily on the variables outside of the scope of the search function. However, I didn’t understand this code because of the marked lines. It is recursive, but this recursion relies on the mutable variable subset.\nIf we employ immutability here we could get a slightly better code:\nvar subsets = function (nums) { let res = []; let n = nums.length; function search(i, acc = []) { if (i == n) { res.push(acc); } else { search(i + 1, acc); search(i + 1, acc.concat([nums[i]])); } } search(0); return res; }; Links Permutations, Combinations, \u0026 Subsets by JB on dev.to ","wordCount":"268","inLanguage":"en","datePublished":"2021-09-01T00:00:00Z","dateModified":"2021-09-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://raqystyle.github.io/blog/generating-a-power-set-of-a-set/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://raqystyle.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://raqystyle.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://raqystyle.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://raqystyle.github.io/about/ title=About><span>About</span></a></li><li><a href=https://raqystyle.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://raqystyle.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li><li><a href=https://raqystyle.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Generating a power set of a set</h1><div class=post-meta><span title='2021-09-01 00:00:00 +0000 UTC'>September 1, 2021</span>&nbsp;·&nbsp;2 min&nbsp;|&nbsp;<a href=https://github.com/raqystyle/raqystyle.github.io/content/blog/generating-a-power-set-of-a-set.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>There&rsquo;s a class of problems that deal with subsets, permutations and so on. Let&rsquo;s find a way to generate a power set of a set with distinct elements. This is a <a href=https://leetcode.com/problems/subsets/>problem #78 on LeetCode</a>.</p><h2 id=what-is-backtracking>What is backtracking?<a hidden class=anchor aria-hidden=true href=#what-is-backtracking>#</a></h2><p>According to <a href=https://en.wikipedia.org/wiki/Backtracking>Wikipedia</a>, backtracking is a general algorithm (or an idea) of searching all the solutions by reducing the search space. It&rsquo;s really close to brute force, try all the options. But at some point we need to take a step back (backtrack) if we cannot proceed.</p><p>Some classical problems that can be solved by the backtracking are:</p><ul><li><a href="https://www.youtube.com/watch?v=wGbuCyNpxIg" title="YouTube video by Back To Back SWE on the N-queens problem">N-queens problem</a></li><li><a href="https://www.youtube.com/watch?v=G_UYXzGuqvM" title="Video by Computerphile on the Sudoku Solver">Sudoku Solver</a></li><li><a href="https://www.youtube.com/watch?v=oTTzNMHM05I" title="Video by Abdul Bari on the Knapsack Problem">Knapsack Problem</a></li><li><a href="https://www.youtube.com/watch?v=GCm7m5671Ps" title="Video by Back To Back SWE on the Permutations">Generating Permutations</a></li></ul><h2 id=so-back-to-the-power-sets>So, back to the power sets<a hidden class=anchor aria-hidden=true href=#so-back-to-the-power-sets>#</a></h2><p>So, the task is, given a set, find the power set of that set:</p><pre tabindex=0><code>Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre><p>I once stumbled upon the following snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>search</span>(<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>n</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>subset</span>)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>k</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>subset</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>k</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>k</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>subset</span>.<span style=color:#a6e22e>pop</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This piece of code relies heavily on the variables outside of the scope of the <code>search</code> function. However, I didn&rsquo;t understand this code because of the marked lines. It is recursive, but this recursion relies on the mutable variable <code>subset</code>.</p><p>If we employ immutability here we could get a slightly better code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>subsets</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>nums</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>nums</span>.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>acc</span> <span style=color:#f92672>=</span> []) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>n</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>acc</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>acc</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>acc</span>.<span style=color:#a6e22e>concat</span>([<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]]));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>search</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=links>Links<a hidden class=anchor aria-hidden=true href=#links>#</a></h4><ul><li><a href=https://dev.to/jjb/part-14-permutations-combinations-subsets-3i7p>Permutations, Combinations, & Subsets by JB on dev.to</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://raqystyle.github.io/tags/algorithms/>algorithms</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://raqystyle.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>