<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Model errors as data for better user and developer experience | Ivan's blog</title><meta name=keywords content="architecture,developer experience,user experience,typescript"><meta name=description content="A great product experience is when the product works as expected in the scenario it was designed for, and communicates with users in a meaningful way. As developers, we cannot control how and where our product will be used, or the user input. But we have the tools to guard the flow from unexpected inputs. In this post, I want to give two pieces of advice for people working in the JS ecosystem on how to create better programs."><meta name=author content><link rel=canonical href=https://ivan-demchenko.github.io/blog/models-errors-as-data/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://ivan-demchenko.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://ivan-demchenko.github.io/static/icon32.png><link rel=apple-touch-icon href=https://ivan-demchenko.github.io/static/icon.png><link rel=mask-icon href=https://ivan-demchenko.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="Model errors as data for better user and developer experience"><meta property="og:description" content="A great product experience is when the product works as expected in the scenario it was designed for, and communicates with users in a meaningful way. As developers, we cannot control how and where our product will be used, or the user input. But we have the tools to guard the flow from unexpected inputs. In this post, I want to give two pieces of advice for people working in the JS ecosystem on how to create better programs."><meta property="og:type" content="article"><meta property="og:url" content="https://ivan-demchenko.github.io/blog/models-errors-as-data/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-01-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Model errors as data for better user and developer experience"><meta name=twitter:description content="A great product experience is when the product works as expected in the scenario it was designed for, and communicates with users in a meaningful way. As developers, we cannot control how and where our product will be used, or the user input. But we have the tools to guard the flow from unexpected inputs. In this post, I want to give two pieces of advice for people working in the JS ecosystem on how to create better programs."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ivan-demchenko.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Model errors as data for better user and developer experience","item":"https://ivan-demchenko.github.io/blog/models-errors-as-data/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Model errors as data for better user and developer experience","name":"Model errors as data for better user and developer experience","description":"A great product experience is when the product works as expected in the scenario it was designed for, and communicates with users in a meaningful way. As developers, we cannot control how and where our product will be used, or the user input. But we have the tools to guard the flow from unexpected inputs. In this post, I want to give two pieces of advice for people working in the JS ecosystem on how to create better programs.","keywords":["architecture","developer experience","user experience","typescript"],"articleBody":"A great product experience is when the product works as expected in the scenario it was designed for, and communicates with users in a meaningful way. As developers, we cannot control how and where our product will be used, or the user input. But we have the tools to guard the flow from unexpected inputs. In this post, I want to give two pieces of advice for people working in the JS ecosystem on how to create better programs.\nI briefly spoke about these ideas in my other blog post and went into more detail in my video.\nDon’t throw exceptions Instead, return the data at all times. In JS (as well as TS), nobody is forced to handle exceptions! The problem is that exceptions break the flow, much like the return statement. Besides, you never know if the function you called may throw (unless you checked the source code) or whether your users will handle the exception. Therefore, the best you can do is to not use the exceptions to communicate an error or unexpected data. Instead, you can always return the data.\nBad:\nconst div = (a: number, b: number): number { if (b === 0) { // Callers have no way of knowing the function can fail throw new Error('Division by 0'); } return a / b; } Don’t reject promises Instead, resolve them with data at all times. You see, conceptually, there’s no difference between rejecting promises and throwing an exception. Therefore, always return from your async function, or in other words, always resolve promises.\nBad:\nconst saveUser = async (user: User): Promise\u003cvoid\u003e { if (!user.someProperty) { throw new Error(\"Some property is missing\"); } return myDb.write(user); } What kind of data to return? The Result type. In TypeScript projects, I’d recommend starting with the ts-results library. You see, other languages solved this problem years ago, for example, Haskell, Rust, Elm, etc. There are more robust libraries for TypeScript, but the ts-results is very easy to adopt, and when you’re hooked (you will be), you can take a look at something more encompassing.\nGood:\nimport {Result, Ok, Err} from \"ts-results\" // ... const div = (a: number, b: number): Result\u003cnumber, string\u003e { if (b === 0) { return new Err(\"Division by 0\"); } return new Ok(a / b); } // ... // Model the potential errors type SaveUserError = | { _type: \"missing_data\", details: ... } | { _type: \"db_error\", details: ... } const saveUser = async ( user: User ): Promise\u003cResult\u003cvoid, SaveUserError\u003e\u003e { if (!user.someProperty) { return new Err({ _type: \"missing_data\", details: `property \"Some\" is missing` }); } try { return new Ok(await myDb.write(user)); } catch (e) { return new Err({ _type: \"db_error\", details: e }); } } Think about integrations If you use a 3rd party library - which you can’t control, it’s in somebody’s else mercy - just wrap the call in a try-catch and return a value of a Result type. As a nice bonus, you can monitor the actual defects in the library by adding logging to this place of your code. Same for the promise-returning functions.\nBad:\nimport { someFn } from \"npm-wild-west\"; function doStuff(): number { // let's pretend we trust it works 100% and always return a number return someFn() } Good:\nimport { someFn } from \"npm-wild-west\"; type DoStuffErr = { _type: \"NPM_LIB_ERR\", details: ... } function doStuff(): Result\u003cnumber, DoStuffErr\u003e { try { return new Ok(someFn()); } catch (e) { myLoggingSystem.error(\"Integration error\", \"someFn from npm-wild-west misbehaved\"); return new Err({ _type: \"NPM_LIB_ERR\", details: e }); } } Model the errors Imagine a user receiving a cryptic error message, something about EACCES. Think about your colleagues (or yourself) parsing through the logging system and seeing those cryptic error messages originating from a minified JS code. To make it worse, let’s say it comes from a global handler for unhandled rejections or exceptions.\nA good debugging experience starts with code that is easy to debug, the code that gives you clues. Conceptually, there’s no difference between a frustrated developer (in front of a logging system) and a frustrated user (trying to understand what is happening). Therefore, use the opportunity to guard yourself against errors that a 3rd party system of a library may produce, log them and write meaningful (in the context of the system) messages. Create a thin wrapper around the integration with that 3rd party to translate exceptions into values. The users (perhaps even yourself) of your code will then be forced to handle both cases (unless you use JS which is bollocks).\nA type checker can check many things for you in real time, eliminating some trivial sanity-check unit tests. You’d better use the energy to write more meaningful tests (unit, integration, e2e, whatever).\nConclusion This whole topic is about a mindset. Thinking about the exceptional state the program may end up in during the execution and modelling the errors as data will help your users understand what went wrong, and help you understand where the error comes from and why. Adopting an errors-as-a-data mindset leads to a better user experience and developer experience.\n","wordCount":"846","inLanguage":"en","datePublished":"2024-01-15T00:00:00Z","dateModified":"2024-01-15T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivan-demchenko.github.io/blog/models-errors-as-data/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://ivan-demchenko.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ivan-demchenko.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ivan-demchenko.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://ivan-demchenko.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ivan-demchenko.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ivan-demchenko.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Model errors as data for better user and developer experience</h1><div class=post-meta><span title='2024-01-15 00:00:00 +0000 UTC'>January 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;|&nbsp;<a href=https://github.com/ivan-demchenko/ivan-demchenko.github.io/blog/2024-01-15-models-errors-as-data.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>A great product experience is when the product works as expected in the scenario it was designed for, and communicates with users in a meaningful way. As developers, we cannot control how and where our product will be used, or the user input. But we have the tools to guard the flow from unexpected inputs. In this post, I want to give two pieces of advice for people working in the JS ecosystem on how to create better programs.</p><p>I briefly spoke about these ideas in my other <a href=/blog/common-mistakes-when-using-typescript/>blog post</a> and went into more detail in my <a href="https://www.youtube.com/watch?v=GfM5BzW5Slc">video</a>.</p><h2 id=dont-throw-exceptions>Don&rsquo;t throw exceptions<a hidden class=anchor aria-hidden=true href=#dont-throw-exceptions>#</a></h2><p>Instead, return the data at all times. In JS (as well as TS), nobody is forced to handle exceptions! The problem is that exceptions break the flow, much like the <code>return</code> statement. Besides, you never know if the function you called may throw (unless you checked the source code) or whether your users will handle the exception. Therefore, the best you can do is to not use the exceptions to communicate an error or unexpected data. Instead, you can always return the data.</p><p>Bad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>div</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Callers have no way of knowing the function can fail
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Division by 0&#39;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=dont-reject-promises>Don&rsquo;t reject promises<a hidden class=anchor aria-hidden=true href=#dont-reject-promises>#</a></h2><p>Instead, resolve them with data at all times. You see, conceptually, there&rsquo;s no difference between rejecting promises and throwing an exception. Therefore, always return from your async function, or in other words, always resolve promises.</p><p>Bad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>saveUser</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>user</span>: <span style=color:#66d9ef>User</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>someProperty</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Some property is missing&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myDb</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>user</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=what-kind-of-data-to-return>What kind of data to return?<a hidden class=anchor aria-hidden=true href=#what-kind-of-data-to-return>#</a></h2><p>The <code>Result</code> type. In TypeScript projects, I&rsquo;d recommend starting with the <a href=https://github.com/vultix/ts-results>ts-results</a> library. You see, other languages solved this problem years ago, for example, <a href=https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Either.html>Haskell</a>, <a href=https://doc.rust-lang.org/std/result/>Rust</a>, <a href=https://package.elm-lang.org/packages/elm/core/latest/Result>Elm</a>, etc. There are more robust libraries for TypeScript, but the <a href=https://github.com/vultix/ts-results>ts-results</a> is very easy to adopt, and when you&rsquo;re hooked (you will be), you can take a look at something more encompassing.</p><p>Good:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>Result</span>, <span style=color:#a6e22e>Ok</span>, <span style=color:#a6e22e>Err</span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;ts-results&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>div</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Result</span>&lt;<span style=color:#f92672>number</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>string</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Err</span>(<span style=color:#e6db74>&#34;Division by 0&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Ok</span>(<span style=color:#a6e22e>a</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>b</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Model the potential errors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SaveUserError</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> { <span style=color:#a6e22e>_type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;missing_data&#34;</span>, <span style=color:#a6e22e>details</span>: <span style=color:#66d9ef>...</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> { <span style=color:#a6e22e>_type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;db_error&#34;</span>, <span style=color:#a6e22e>details</span>: <span style=color:#66d9ef>...</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>saveUser</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>user</span>: <span style=color:#66d9ef>User</span>
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>void</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>SaveUserError</span>&gt;<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>someProperty</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Err</span>({ <span style=color:#a6e22e>_type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;missing_data&#34;</span>, <span style=color:#a6e22e>details</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`property &#34;Some&#34; is missing`</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Ok</span>(<span style=color:#66d9ef>await</span> <span style=color:#a6e22e>myDb</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>user</span>));
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Err</span>({ <span style=color:#a6e22e>_type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;db_error&#34;</span>, <span style=color:#a6e22e>details</span>: <span style=color:#66d9ef>e</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=think-about-integrations>Think about integrations<a hidden class=anchor aria-hidden=true href=#think-about-integrations>#</a></h2><p>If you use a 3rd party library - which you can&rsquo;t control, it&rsquo;s in somebody&rsquo;s else mercy - just wrap the call in a try-catch and return a value of a <code>Result</code> type. As a nice bonus, you can monitor the actual defects in the library by adding logging to this place of your code. Same for the promise-returning functions.</p><p>Bad:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>someFn</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;npm-wild-west&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>doStuff</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// let&#39;s pretend we trust it works 100% and always return a number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>someFn</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Good:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>someFn</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;npm-wild-west&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DoStuffErr</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;NPM_LIB_ERR&#34;</span>, <span style=color:#a6e22e>details</span>: <span style=color:#66d9ef>...</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>doStuff</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Result</span>&lt;<span style=color:#f92672>number</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>DoStuffErr</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Ok</span>(<span style=color:#a6e22e>someFn</span>());
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>myLoggingSystem</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Integration error&#34;</span>, <span style=color:#e6db74>&#34;someFn from npm-wild-west misbehaved&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Err</span>({ <span style=color:#a6e22e>_type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;NPM_LIB_ERR&#34;</span>, <span style=color:#a6e22e>details</span>: <span style=color:#66d9ef>e</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=model-the-errors>Model the errors<a hidden class=anchor aria-hidden=true href=#model-the-errors>#</a></h2><p>Imagine a user receiving a cryptic error message, something about EACCES. Think about your colleagues (or yourself) parsing through the logging system and seeing those cryptic error messages originating from a minified JS code. To make it worse, let&rsquo;s say it comes from a global handler for unhandled rejections or exceptions.</p><p>A good debugging experience starts with code that is easy to debug, the code that gives you clues. Conceptually, there&rsquo;s no difference between a frustrated developer (in front of a logging system) and a frustrated user (trying to understand what is happening). Therefore, use the opportunity to guard yourself against errors that a 3rd party system of a library may produce, log them and write meaningful (in the context of the system) messages. Create a thin wrapper around the integration with that 3rd party to translate exceptions into values. The users (perhaps even yourself) of your code will then be forced to handle both cases (unless you use JS which is bollocks).</p><p>A type checker can check many things for you in real time, eliminating some trivial sanity-check unit tests. You&rsquo;d better use the energy to write more meaningful tests (unit, integration, e2e, whatever).</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This whole topic is about a mindset. Thinking about the exceptional state the program may end up in during the execution and modelling the errors as data will help your users understand what went wrong, and help you understand where the error comes from and why. Adopting an errors-as-a-data mindset leads to a better user experience and developer experience.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ivan-demchenko.github.io/tags/architecture/>architecture</a></li><li><a href=https://ivan-demchenko.github.io/tags/developer-experience/>developer experience</a></li><li><a href=https://ivan-demchenko.github.io/tags/user-experience/>user experience</a></li><li><a href=https://ivan-demchenko.github.io/tags/typescript/>typescript</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ivan-demchenko.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript>var sc_project=12781072,sc_invisible=1,sc_security="4d31877b"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12781072/0/4d31877b/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>