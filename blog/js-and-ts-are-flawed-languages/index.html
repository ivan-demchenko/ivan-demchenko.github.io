<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TypeScript inherits all the flaws of JavaScript | Ivan's blog</title><meta name=keywords content="JavaScript,Observations,TypeScript,Type systems"><meta name=description content="Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.
The problem Consider a function that turns an object representing a URL into a string:
type UrlRecord = { protocol: string; host: string[]; } function urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host.join('.')}`; } This code snippet looks innocent and pretty solid."><meta name=author content><link rel=canonical href=https://raqystyle.github.io/blog/js-and-ts-are-flawed-languages/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raqystyle.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://raqystyle.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://raqystyle.github.io/static/icon32.png><link rel=apple-touch-icon href=https://raqystyle.github.io/static/icon.png><link rel=mask-icon href=https://raqystyle.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="TypeScript inherits all the flaws of JavaScript"><meta property="og:description" content="Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.
The problem Consider a function that turns an object representing a URL into a string:
type UrlRecord = { protocol: string; host: string[]; } function urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host.join('.')}`; } This code snippet looks innocent and pretty solid."><meta property="og:type" content="article"><meta property="og:url" content="https://raqystyle.github.io/blog/js-and-ts-are-flawed-languages/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TypeScript inherits all the flaws of JavaScript"><meta name=twitter:description content="Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.
The problem Consider a function that turns an object representing a URL into a string:
type UrlRecord = { protocol: string; host: string[]; } function urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host.join('.')}`; } This code snippet looks innocent and pretty solid."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://raqystyle.github.io/blog/"},{"@type":"ListItem","position":2,"name":"TypeScript inherits all the flaws of JavaScript","item":"https://raqystyle.github.io/blog/js-and-ts-are-flawed-languages/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TypeScript inherits all the flaws of JavaScript","name":"TypeScript inherits all the flaws of JavaScript","description":"Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.\nThe problem Consider a function that turns an object representing a URL into a string:\ntype UrlRecord = { protocol: string; host: string[]; } function urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host.join(\u0026#39;.\u0026#39;)}`; } This code snippet looks innocent and pretty solid.","keywords":["JavaScript","Observations","TypeScript","Type systems"],"articleBody":"Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.\nThe problem Consider a function that turns an object representing a URL into a string:\ntype UrlRecord = { protocol: string; host: string[]; } function urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host.join('.')}`; } This code snippet looks innocent and pretty solid. TypeScript compiler will let the users of this function know if they are passing the wrong data into the function:\nconsole.log(urlToString({ protocol: 'http', host: 'g.com' })); // \u003e TS Error: Type 'string' is not assignable to type 'string[]'. Great! However, how would TypeScript react to this change:\nfunction urlToString(urlRecord: UrlRecord): string { const { protocol, host } = urlRecord; return `${protocol}://${host}`; } It is somewhat of a subtle change, and it is easy to overlook it during the code review. TypeScript was also okay with this change, because the corresponding JavaScript code will work just fine. The reason being the algorithm that governs String interpolation.\nTemplate literals coerce their expressions directly to strings, while addition coerces its operands to primitives first.\nTypeScript inherits this behaviour. After all,\nTypeScript is JavaScript with syntax for types.\n© TypeScript website\nWe can even change UrlRecord type and it won’t make any difference:\ntype UrlRecord = { protocol: string, host: string }; type UrlRecord = { protocol: string, host: Record\u003cstring, string[]\u003e }; type UrlRecord = { protocol: string, host?: string | null }; type UrlRecord = { protocol: string, host: unknown }; type UrlRecord = { protocol: string, host: never }; TypeScript will correctly infer the type of host, but still won’t bother about the string interpolation, because JavaScript will do its implicit ToString business and make everything work no matter what. Only the users of the urlToString function will notice the difference. Don’t get me wrong, it is already a big win compared to not having a compiler at all.\nDon’t forget about the unit tests Although this example may not look very convincing in isolation, within a larger codebase, mistakes like this may easily slip through unnoticed. It’s easy to imagine a scenario when this function is used by other people in your organisation with a false impression that TypeScript will somehow guarantee correctness. This is why, sometimes, you may see weird things such as http://undefined/api/... or Price: $ NaN.\nThis example shows that because we rely on a JavaScript’s feature here (string interpolation), we need to be mindful of all possible edge cases and write all sort of unit tests, as if we didn’t have any type system. In fact, this function is a perfect candidate for TDD.\nWe need to always keep in mind that TypeScript is a layer on top of JavaScript, with all its quirks and weirdness. Having a type system should help discover such bugs early.\nBesides, as authors (or maybe even users) of the urlToString function, we cannot know where the payload for it comes from. Fair enough, Type\nCan we do better? Spoiler alert: yes, we can! Let’s explore how ReScript handles this situation. This is the setup:\ntype urlObj = { protocol: string, host: string, } let urlObjToStr = obj =\u003e { `${obj.protocol}://${obj.host}` } This is how we would use the function:\nJs.Console.log(urlObjToStr({ protocol: \"http\", host: \"google.com\" })) (** \u003e Ok *) Js.Console.log( urlObjToStr({ protocol: \"http\", host: list{\"google\", \"com\"} ~~~~~~~~~~~~~~~~~~~~~ (** This has type: list\u003c'a\u003e *) (** Somewhere wanted: string *) }) ) Essentially, this error says “You are giving it a list instead of a string”\nSo far so good, similar to the TypeScript, we cannot pass the wrong data into the function. However, if we change the function itself, we get a different outcome:\nlet urlObjToStr = obj =\u003e { `${obj.protocol}://${obj.host-\u003eArray.joinWith(\".\")}` ~~~~~~~~ (** This has type: string *) (** Somewhere wanted: array\u003c'a\u003e *) } Interesting! ReScript figured out that obj is of type urlObj even without explicit type annotation! This is the power of a sound type system! Look what happens when we add the following type:\ntype urlObj2 = { protocol: string, host: array\u003cstring\u003e, } let urlObjToStr = obj =\u003e { `${obj.protocol}://${obj.host-\u003eArray.joinWith(\".\")}` } (** \u003e Ok *) Now the compiler can infer that the type of obj is urlObj2, just by looking at the code! Now we get some proper guidance from the compiler:\nJs.Console.log( urlObjToStr({ protocol: \"http\", host: \"google.com\", ~~~~~~~~~~~~ (** This has type: list\u003c'a\u003e *) (** Somewhere wanted: array *) }), ) Unknown source of data Earlier I mentioned that we cannot be sure where the data comes from. If the input is generated by a program that is maintained by a colleague who sits right next to us, we still cannot trust the incoming data. Always keep in mind Murphy’s law:\nAnything that can go wrong will go wrong\nLet’s say we read the data from localStorage:\nlet data = Dom.Storage.getItem(\"some-key\", Dom.Storage.localStorage) (** data : option *) In TypeScript, we could simply:\nconst data = window.localStorage.getItem(\"test\"); // string | null urlToString(JSON.parse(data || \"\")) // Ok This won’t be possible in ReScript. Instead, we need to parse and decode the data. Without these steps, there’s no way we can guarantee that the program works properly. Parsing and decoding steps may fail for different reasons and we, as the library authors have to handle this. So, here we go:\nlet safeParseJSON = (s: string): option\u003cJs.Json.t\u003e =\u003e { switch Js.Json.parseExn(s) { | val =\u003e Some(val) | exception _ =\u003e None } } let decodeUrlObj = (s: string): option\u003curlObj\u003e =\u003e { (** make sure the string is a valid JSON *) safeParseJSON(s)-\u003eOption.flatMap(json =\u003e (** let's see what is that JSON *) switch Js.Json.classify(json) { (** it is an object *) | Js.Json.JSONObject(value) =\u003e value (** try reading the \"protocol\" field *) -\u003eJs.Dict.get(\"protocol\") (** ... and make sure it a string *) -\u003eOption.flatMap(Js.Json.decodeString) -\u003eOption.flatMap(protocol =\u003e { value (** try reading the \"host\" field *) -\u003eJs.Dict.get(\"host\") (** ... and make sure it a string *) -\u003eOption.flatMap(Js.Json.decodeString) (** Finally, having everything we need, build a url object *) -\u003eOption.map(host =\u003e {protocol, host}) }) | _ =\u003e None } ) } switch data-\u003eOption.flatMap(decodeUrlObj) { | Some(urlObj) =\u003e Console.log(urlObjToStr(urlObj)) | None =\u003e Console.log(\"Failed to parse the data\") } First, safeParseJSON function helps us make sure that we received valid JSON. Then we run a decoder as part of the decodeUrlObj function. Notice that use pattern matching to handle different branches in the business logic. For example, we may receive a string with invalid JSON, or the JSON may not be an object, etc.\nI used here a default, built-in JSON decoding facilities. There are far more expressive and easy-to-use libraries for decoding out there.\nThe flatMap operator defined on option\u003c't\u003e helps to chain the computation together without explicit pattern matching. This makes the code compact, yet descriptive.\nThe only issue I have with the code is that exception handling in the safeParseJSON function. If we remove that branch and the compiler won’t complain. However, this issue can easily be prevented using ReScript’s code analyser tool - it will notify us that the function may throw.\nAll of this shows how much validation we may miss when writing TypeScript simply because the language does not require any of that. Without all of those checks, we cannot guarantee that our program will not crash. Having types such as option instead of null or undefined being a part of the standard library is just great! However, we can have a similar setup with TypeScript, which we’ll explore in a following post. For now, I would highly encourage you to explore ReScript.\n","wordCount":"1265","inLanguage":"en","datePublished":"2023-10-30T00:00:00Z","dateModified":"2023-10-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://raqystyle.github.io/blog/js-and-ts-are-flawed-languages/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://raqystyle.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://raqystyle.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://raqystyle.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://raqystyle.github.io/about/ title=About><span>About</span></a></li><li><a href=https://raqystyle.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://raqystyle.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li><li><a href=https://raqystyle.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>TypeScript inherits all the flaws of JavaScript</h1><div class=post-meta><span title='2023-10-30 00:00:00 +0000 UTC'>October 30, 2023</span>&nbsp;·&nbsp;6 min&nbsp;|&nbsp;<a href=https://github.com/raqystyle/raqystyle.github.io/content/blog/js-and-ts-are-flawed-languages.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Being a big proponent of TypeScript, I keep noticing that this language inherits all the flaws of JavaScript. However, it does not mean we have no choice.</p><h2 id=the-problem>The problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h2><p>Consider a function that turns an object representing a URL into a string:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UrlRecord</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>string</span>[];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>urlToString</span>(<span style=color:#a6e22e>urlRecord</span>: <span style=color:#66d9ef>UrlRecord</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>protocol</span>, <span style=color:#a6e22e>host</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>urlRecord</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>protocol</span><span style=color:#e6db74>}</span><span style=color:#e6db74>://</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>host</span>.<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#39;.&#39;</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code snippet looks innocent and pretty solid. TypeScript compiler will let the users of this function know if they are passing the wrong data into the function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>urlToString</span>({ <span style=color:#a6e22e>protocol</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;http&#39;</span>, <span style=color:#a6e22e>host</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;g.com&#39;</span> }));
</span></span><span style=display:flex><span><span style=color:#75715e>// &gt; TS Error: Type &#39;string&#39; is not assignable to type &#39;string[]&#39;.
</span></span></span></code></pre></div><p>Great! However, how would TypeScript react to this change:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>urlToString</span>(<span style=color:#a6e22e>urlRecord</span>: <span style=color:#66d9ef>UrlRecord</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>protocol</span>, <span style=color:#a6e22e>host</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>urlRecord</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>protocol</span><span style=color:#e6db74>}</span><span style=color:#e6db74>://</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>host</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is somewhat of a subtle change, and it is easy to overlook it during the code review. TypeScript was also okay with this change, because the corresponding JavaScript code will work just fine. The reason being the algorithm that governs <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#string_interpolation>String interpolation</a>.</p><blockquote><p>Template literals <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion>coerce their expressions directly to strings</a>, while addition coerces its operands to primitives first.</p></blockquote><p>TypeScript inherits this behaviour. After all,</p><blockquote><p>TypeScript is JavaScript with syntax for types.</p></blockquote><p>© <a href=https://www.typescriptlang.org/>TypeScript website</a></p><p>We can even change <code>UrlRecord</code> type and it won&rsquo;t make any difference:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UrlRecord</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>string</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UrlRecord</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>string</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UrlRecord</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>host?</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UrlRecord</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>unknown</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UrlRecord</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>protocol</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>never</span> };
</span></span></code></pre></div><p>TypeScript will correctly infer the type of <code>host</code>, but still won&rsquo;t bother about the string interpolation, because JavaScript will do its implicit <a href=https://tc39.es/ecma262/#sec-tostring>ToString</a> business and make everything work no matter what. Only the users of the <code>urlToString</code> function will notice the difference. Don&rsquo;t get me wrong, it is already a big win compared to not having a compiler at all.</p><h2 id=dont-forget-about-the-unit-tests>Don&rsquo;t forget about the unit tests<a hidden class=anchor aria-hidden=true href=#dont-forget-about-the-unit-tests>#</a></h2><p>Although this example may not look very convincing in isolation, within a larger codebase, mistakes like this may easily slip through unnoticed. It&rsquo;s easy to imagine a scenario when this function is used by other people in your organisation with a false impression that TypeScript will somehow guarantee correctness. This is why, sometimes, you may see weird things such as <code>http://undefined/api/...</code> or <code>Price: $ NaN</code>.</p><p>This example shows that because we rely on a JavaScript&rsquo;s feature here (string interpolation), we need to be mindful of all possible edge cases and write all sort of unit tests, as if we didn&rsquo;t have any type system. In fact, this function is a perfect candidate for TDD.</p><p>We need to always keep in mind that TypeScript is a layer on top of JavaScript, with all its quirks and weirdness. Having a type system should help discover such bugs early.</p><p>Besides, as authors (or maybe even users) of the <code>urlToString</code> function, we cannot know where the payload for it comes from. Fair enough, Type</p><h2 id=can-we-do-better>Can we do better?<a hidden class=anchor aria-hidden=true href=#can-we-do-better>#</a></h2><p>Spoiler alert: yes, we can! Let&rsquo;s explore how ReScript handles this situation. This is the setup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> urlObj <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  protocol<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  host<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> urlObjToStr <span style=color:#f92672>=</span> obj <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>`${</span>obj<span style=color:#f92672>.</span>protocol<span style=color:#f92672>}://${</span>obj<span style=color:#f92672>.</span>host<span style=color:#f92672>}`</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>This is how we would use the function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>Js.Console.log<span style=color:#f92672>(</span>urlObjToStr<span style=color:#f92672>({</span> protocol<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;http&#34;</span><span style=color:#f92672>,</span> host<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;google.com&#34;</span> <span style=color:#f92672>}))</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(** &gt; Ok *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Js.Console.log<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>  urlObjToStr<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>    protocol<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;http&#34;</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    host<span style=color:#f92672>:</span> <span style=color:#66d9ef>list</span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;google&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;com&#34;</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>~~~~~~~~~~~~~~~~~~~~~</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(** This has type: list&lt;&#39;a&gt;  *)</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(** Somewhere wanted: string *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Essentially, this error says &ldquo;You are giving it a list instead of a string&rdquo;</p><p>So far so good, similar to the TypeScript, we cannot pass the wrong data into the function. However, if we change the function itself, we get a different outcome:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> urlObjToStr <span style=color:#f92672>=</span> obj <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>`${</span>obj<span style=color:#f92672>.</span>protocol<span style=color:#f92672>}://${</span>obj<span style=color:#f92672>.</span>host<span style=color:#f92672>-&gt;</span>Array.joinWith<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;.&#34;</span><span style=color:#f92672>)}`</span>
</span></span><span style=display:flex><span>                       <span style=color:#f92672>~~~~~~~~</span>
</span></span><span style=display:flex><span>                       <span style=color:#75715e>(** This has type: string       *)</span>
</span></span><span style=display:flex><span>                       <span style=color:#75715e>(** Somewhere wanted: array&lt;&#39;a&gt; *)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Interesting! ReScript figured out that <code>obj</code> is of type <code>urlObj</code> even without explicit type annotation! This is the power of a sound type system! Look what happens when we add the following type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> urlObj2 <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  protocol<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  host<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>string</span><span style=color:#f92672>&gt;,</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> urlObjToStr <span style=color:#f92672>=</span> obj <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>`${</span>obj<span style=color:#f92672>.</span>protocol<span style=color:#f92672>}://${</span>obj<span style=color:#f92672>.</span>host<span style=color:#f92672>-&gt;</span>Array.joinWith<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;.&#34;</span><span style=color:#f92672>)}`</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(** &gt; Ok *)</span>
</span></span></code></pre></div><p>Now the compiler can infer that the type of <code>obj</code> is <code>urlObj2</code>, just by looking at the code! Now we get some proper guidance from the compiler:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>Js.Console.log<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>  urlObjToStr<span style=color:#f92672>({</span>
</span></span><span style=display:flex><span>    protocol<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;http&#34;</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    host<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;google.com&#34;</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>~~~~~~~~~~~~</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(** This has type: list&lt;&#39;a&gt;         *)</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>(** Somewhere wanted: array&lt;string&gt; *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}),</span>
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span></code></pre></div><h2 id=unknown-source-of-data>Unknown source of data<a hidden class=anchor aria-hidden=true href=#unknown-source-of-data>#</a></h2><p>Earlier I mentioned that we cannot be sure where the data comes from. If the input is generated by a program that is maintained by a colleague who sits right next to us, we still cannot trust the incoming data. Always keep in mind Murphy&rsquo;s law:</p><blockquote><p>Anything that can go wrong will go wrong</p></blockquote><p>Let&rsquo;s say we read the data from <code>localStorage</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> data <span style=color:#f92672>=</span> Dom.Storage.getItem<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;some-key&#34;</span><span style=color:#f92672>,</span> Dom.Storage.localStorage<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(** data : option&lt;string&gt; *)</span>
</span></span></code></pre></div><p>In TypeScript, we could simply:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> window.<span style=color:#a6e22e>localStorage</span>.<span style=color:#a6e22e>getItem</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// string | null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>urlToString</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#75715e>// Ok
</span></span></span></code></pre></div><p>This won&rsquo;t be possible in ReScript. Instead, we need to parse and decode the data. Without these steps, there&rsquo;s no way we can guarantee that the program works properly. Parsing and decoding steps may fail for different reasons and we, as the library authors have to handle this. So, here we go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> safeParseJSON <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>s<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>):</span> option<span style=color:#f92672>&lt;</span>Js.Json.t<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  switch Js.Json.parseExn<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#66d9ef>val</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Some</span><span style=color:#f92672>(</span><span style=color:#66d9ef>val</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#66d9ef>exception</span> <span style=color:#f92672>_</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> decodeUrlObj <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>s<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span><span style=color:#f92672>):</span> option<span style=color:#f92672>&lt;</span>urlObj<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** make sure the string is a valid JSON *)</span>
</span></span><span style=display:flex><span>  safeParseJSON<span style=color:#f92672>(</span>s<span style=color:#f92672>)-&gt;</span>Option.flatMap<span style=color:#f92672>(</span>json <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(** let&#39;s see what is that JSON *)</span>
</span></span><span style=display:flex><span>    switch Js.Json.classify<span style=color:#f92672>(</span>json<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(** it is an object *)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> Js.Json.<span style=color:#a6e22e>JSONObject</span><span style=color:#f92672>(</span><span style=color:#66d9ef>value</span><span style=color:#f92672>)</span> <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>value</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(** try reading the &#34;protocol&#34; field *)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>-&gt;</span>Js.Dict.get<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;protocol&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(** ... and make sure it a string *)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>-&gt;</span>Option.flatMap<span style=color:#f92672>(</span>Js.Json.decodeString<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>-&gt;</span>Option.flatMap<span style=color:#f92672>(</span>protocol <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>value</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(** try reading the &#34;host&#34; field *)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-&gt;</span>Js.Dict.get<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;host&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(** ... and make sure it a string *)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-&gt;</span>Option.flatMap<span style=color:#f92672>(</span>Js.Json.decodeString<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(** Finally, having everything we need, build a url object *)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-&gt;</span>Option.map<span style=color:#f92672>(</span>host <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>{</span>protocol<span style=color:#f92672>,</span> host<span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>switch data<span style=color:#f92672>-&gt;</span>Option.flatMap<span style=color:#f92672>(</span>decodeUrlObj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span><span style=color:#f92672>(</span>urlObj<span style=color:#f92672>)</span> <span style=color:#f92672>=&gt;</span> Console.log<span style=color:#f92672>(</span>urlObjToStr<span style=color:#f92672>(</span>urlObj<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>=&gt;</span> Console.log<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Failed to parse the data&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>First, <code>safeParseJSON</code> function helps us make sure that we received valid JSON. Then we run a decoder as part of the <code>decodeUrlObj</code> function. Notice that use pattern matching to handle different branches in the business logic. For example, we may receive a string with invalid JSON, or the JSON may not be an object, etc.</p><p>I used here a default, built-in JSON decoding facilities. There are far more expressive and easy-to-use libraries for decoding out there.</p><p>The <code>flatMap</code> operator defined on <code>option&lt;'t></code> helps to chain the computation together without explicit pattern matching. This makes the code compact, yet descriptive.</p><p>The only issue I have with the code is that exception handling in the <code>safeParseJSON</code> function. If we remove that branch and the compiler won&rsquo;t complain. However, this issue can easily be prevented using ReScript&rsquo;s code analyser tool - it will notify us that the function may throw.</p><p>All of this shows how much validation we may miss when writing TypeScript simply because the language does not require any of that. Without all of those checks, we cannot guarantee that our program will not crash. Having types such as <code>option</code> instead of <code>null</code> or <code>undefined</code> being a part of the standard library is just great! However, we can have a similar setup with TypeScript, which we&rsquo;ll explore in a following post. For now, I would highly encourage you to explore ReScript.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://raqystyle.github.io/tags/javascript/>JavaScript</a></li><li><a href=https://raqystyle.github.io/tags/observations/>Observations</a></li><li><a href=https://raqystyle.github.io/tags/typescript/>typescript</a></li><li><a href=https://raqystyle.github.io/tags/type-systems/>type systems</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://raqystyle.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript>var sc_project=12781072,sc_invisible=1,sc_security="4d31877b"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12781072/0/4d31877b/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>