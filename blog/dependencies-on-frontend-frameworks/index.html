<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dependencies on (front-end) frameworks | Ivan's blog</title><meta name=keywords content="architecture"><meta name=description content="As modern front-end applications become increasingly complex, it is becoming more and more important to maintain the separation of concerns between the view layer and the business logic.
New toys, old problems Having seen several modern codebases, I can say that history is repeating itself. Back in the day, when PHP was growing in popularity, but the ecosystem was not mature enough, the separation of concerns was a hot topic. For example, rushing to deliver the working code on time, people would query or write to a database directly from the views."><meta name=author content><link rel=canonical href=https://raqystyle.github.io/blog/dependencies-on-frontend-frameworks/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raqystyle.github.io/static/icon.png><link rel=icon type=image/png sizes=16x16 href=https://raqystyle.github.io/static/icon16.png><link rel=icon type=image/png sizes=32x32 href=https://raqystyle.github.io/static/icon32.png><link rel=apple-touch-icon href=https://raqystyle.github.io/static/icon.png><link rel=mask-icon href=https://raqystyle.github.io/static/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-VHCCQB5KTN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VHCCQB5KTN")</script><meta property="og:title" content="Dependencies on (front-end) frameworks"><meta property="og:description" content="As modern front-end applications become increasingly complex, it is becoming more and more important to maintain the separation of concerns between the view layer and the business logic.
New toys, old problems Having seen several modern codebases, I can say that history is repeating itself. Back in the day, when PHP was growing in popularity, but the ecosystem was not mature enough, the separation of concerns was a hot topic. For example, rushing to deliver the working code on time, people would query or write to a database directly from the views."><meta property="og:type" content="article"><meta property="og:url" content="https://raqystyle.github.io/blog/dependencies-on-frontend-frameworks/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-02-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dependencies on (front-end) frameworks"><meta name=twitter:description content="As modern front-end applications become increasingly complex, it is becoming more and more important to maintain the separation of concerns between the view layer and the business logic.
New toys, old problems Having seen several modern codebases, I can say that history is repeating itself. Back in the day, when PHP was growing in popularity, but the ecosystem was not mature enough, the separation of concerns was a hot topic. For example, rushing to deliver the working code on time, people would query or write to a database directly from the views."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://raqystyle.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Dependencies on (front-end) frameworks","item":"https://raqystyle.github.io/blog/dependencies-on-frontend-frameworks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dependencies on (front-end) frameworks","name":"Dependencies on (front-end) frameworks","description":"As modern front-end applications become increasingly complex, it is becoming more and more important to maintain the separation of concerns between the view layer and the business logic.\nNew toys, old problems Having seen several modern codebases, I can say that history is repeating itself. Back in the day, when PHP was growing in popularity, but the ecosystem was not mature enough, the separation of concerns was a hot topic. For example, rushing to deliver the working code on time, people would query or write to a database directly from the views.","keywords":["architecture"],"articleBody":"As modern front-end applications become increasingly complex, it is becoming more and more important to maintain the separation of concerns between the view layer and the business logic.\nNew toys, old problems Having seen several modern codebases, I can say that history is repeating itself. Back in the day, when PHP was growing in popularity, but the ecosystem was not mature enough, the separation of concerns was a hot topic. For example, rushing to deliver the working code on time, people would query or write to a database directly from the views.\nToday we use a different tech stack, but the principles remain the same. With the rise of single-page applications and front-end frameworks, the boundaries between concerns have blurred. Consider a component-based model. The key mantra is that a UI component is an isolated, drop-in piece of a larger system. A component acts as an encapsulation mechanism. Nobody cares what happens inside of that component. But this is exactly how we get ourselves into the “I only wanted a banana, but I got a gorilla and the whole jungle with it” situation.\nFor example, our little Autocomplete UI component can read directly from the API via a service (we often pretend to follow the best practices). Later, the same component can import something called a “UI Manager” and manipulate some other part of the system via an event. All of this may sound unreal, but I have just described a part of a real codebase.\nMoreover, every codebase is bound to end-up like this for several reasons:\nPeople writing code who are unaware of simple engineering principles; Poor planning leading to unrealistic deadlines; The evaluation of people’s output is unbalanced. In other words, when inexperienced people have to cut corners to meet a deadline, neglecting the quality aspects or architectural principles, we end-up in a situation like this. This problem gets exacerbated when lead engineers or engineering managers are judged solely on speed of delivery of their teams.\nSo, why is it a problem? Everything works, doesn’t it? Of course it does! Why shouldn’t it? But because the business logic is spread across the view layer and data is being accessed and written everywhere, the system becomes almost untestable. All of this leads to lesser confidence in developers when they change the code and makes it harder to guarantee that the system will work in the next release. As a result, we end up performing hot fixes during releases and, worst of all, reduced customer confidence and satisfaction.\nAnd as we all know, there’s nothing more permanent than a temporary solution. So, all the quick hacks stay there for a long time. In addition, people leave the company and new people come in. These new people will have to be productive with the code they have inherited. For them it is now legacy code. Also, the business will evolve, some features will become obsolete, some will become really complex. All of that means changing the code. But nobody wants to break the working system. Thus, some people will call for refactoring, others will insist on rewriting. But for business, however, refactoring will only makes sense if it opens the door to more revenue. The problem is that the longer the code remains in this state of mixed concerns, the more expensive it becomes to fix the code.\nThe analogy I use is a fancy restaurant with a neglected kitchen. If nobody cleans the kitchen regularly, eventually the restaurant will have to close for a while and clean up. Closing the restaurant will be far more expensive than regular cleaning.\nAn example I’ll include a few code snippets here to illustrate my ideas. I have deliberately left out some important (but not very relevant to the topic of this post) details.\nLet’s take a look at the Autocomplete UI component. In it’s simplest form, it should act as a simple input with a list of hints that get fetched from a source and displayed to the user. A user can click on a hint to send that value to the component’s consumer.\nimport { debounce } from 'debounce.library' import { AutocompleteList } from '@components/AutocompleteList' import { AutocompleteService } from '@services/AutocompleteService' export function Autocomplete() { const [items, setItems] = useState([]); const fetchItems = (event) =\u003e { const currentValue = event.target.value; AutocompleteService .fetchItems(currentValue) .then(data =\u003e { setItems(data) }); }; const debouncedFetchItems = useMemo(() =\u003e { debounce(fetchItems, 300) }, []); return ( \u003c\u003e \u003cinput onChange={debouncedFetchItems} /\u003e \u003cAutocompleteList items={items} /\u003e \u003c/\u003e ); } On the face of it, this is a fairly common implementation. However, if I want to reuse the autocomplete in a different context, I’ll also get the AutocompleteService and AutocompleteList too, even though I only asked for the Autocomplete UI component.\nNow let’s say we need to add a way to add a missing suggestion. So, we’ll add a small button at the bottom of the list that will open a dialogue box to add an item to the suggestion list. A few weeks later, we realise that the suggestions on a particular page need to be personalised for the current user. I think you can see how complex this small component can become.\nSo, how do we fix this situation? Let’s focus on the code listed above. The first thing I would do is make sure that there’s no direct import of a service into the UI component. Instead, we should declare an interface for our users to implement. Let me illustrate:\ntype Suggestion = { ... } export interface AutocompleteProps { fetchSuggestions(userInput: string): Promise\u003cSuggestion[]\u003e } export function Autocomplete(props: AutocompleteProps) { // ... const fetchItems = (event) =\u003e { const currentValue = event.target.value; props .fetchSuggestions(currentValue) .then(data =\u003e { setItems(data) }); }; // ... } By declaring this interface, Autocomplete frees itself from any notion of services or data stores or apis or whatever. This is called the principle of dependency inversion. By making this change, we get closer to being able to reuse this UI component in other places and feed the information into it from whatever sources. For testing purposes we can simply create a mock implementation of the AutocompleteService.\nThis is a great change to make, much cleaner! However, we are not done yet. You see, our Autocomplete UI component consists of a text input and a list of suggestions. By design our component has two responsibilities: collecting user input and displaying suggestions. However, as we anticipated, we now need to modify the suggestion list. Well, if other parts of the application use this component, we need to make sure that we don’t accidentally introduce a new functionality to them as well. We could, of course, tinker with the props, or make a copy of the whole component. But there’s a much better way.\nThere’s a principle of a single responsibility. In our case, we need to treat a suggestion list as a separate component, not the part of the Autocomplete component. We should also pass it to the Autocomplete via props, rather than importing it directly.\nexport interface AutocompleteProps { // ... suggestionsList: ReactNode } export function Autocomplete(props: AutocompleteProps) { // ... return ( // ... {props.suggestionsList} ); } In this particular example, we delegate the responsibility for implementing or importing the correct suggestion list to the consumer of the autocomplete component. We, as the component authors, can provide a default suggestion list.\nNot just UI components Although, we have focused on the UI code, these principles apply to any other type of code. For example, if you are working on an Electron-based application and need to import something from the electron package, stop and create an interface. You will be amazed at how easy it is to test the business logic, rather than worrying about spinning up an instance of electron when running unit tests.\nAlthough I’ve shown the benefits of injecting dependencies, that doesn’t mean I’m against imports. During code review, look for imports from packages we don’t control and ask the author to create an interface. This interface should convey the intent. For example, instead of using localStorage directly, create an interface with methods like saveUserMetadata or getGameScore. In the class that implements this interface, feel free to use the localStorage, an apiServer, memory or whatever you want.\nRisk for business Typically, frameworks are maintained and developed by third parties. Dependencies on third parties are always risky: the organisation could end up with an abandoned framework. If engineers respect the principle of separation of concerns, replacing this layer would be much less expensive.\nAnother point is that the framework’s licence may change and become too expensive. In this case, without a clean boundary between the business logic and the view layer, the cost of refactoring can be too high for the organisation.\nConclusion Frameworks may seem like the solution to all our problems. But they are not. In the software engineering community, especially in the front-end camp, frameworks are glorified as the way forward, the way to build software. However, very few talk about the problems associated with this kind of thinking, and how to avoid the framework trap.\nOver the years, people have distilled simple but powerful engineering principles that, in my opinion, every engineer should know. The ones I talked about in this article are so called SOLID principles. They are easy to learn as there are plenty of resources available online. If you prefer books, I’d recommend “Clean Architecture” by Robert C. Martin.\nAt first, following these principles may seem like extra work. But these ideas are not a rocket science and are very easy to understand. Over time using them becomes a second nature. So, don’t be intimidated.\nEngineering culture (and work culture, for that matter) is also an important issue to consider. Time to market is an important metric. But code quality, architectural flexibility and testability are equally (if not more) important in the long run.\nIn my opinion, the companies that pay close attention to code quality have an advantage in the market. Similar to a restaurant that maintains both a high quality of food and a clean kitchen.\n","wordCount":"1681","inLanguage":"en","datePublished":"2023-02-20T00:00:00Z","dateModified":"2023-02-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://raqystyle.github.io/blog/dependencies-on-frontend-frameworks/"},"publisher":{"@type":"Organization","name":"Ivan's blog","logo":{"@type":"ImageObject","url":"https://raqystyle.github.io/static/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://raqystyle.github.io/ accesskey=h title="Ivan's blog (Alt + H)">Ivan's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://raqystyle.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://raqystyle.github.io/about/ title=About><span>About</span></a></li><li><a href=https://raqystyle.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://raqystyle.github.io/bookmarks/ title=Bookmarks><span>Bookmarks</span></a></li><li><a href=https://raqystyle.github.io/cv/ title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Dependencies on (front-end) frameworks</h1><div class=post-meta><span title='2023-02-20 00:00:00 +0000 UTC'>February 20, 2023</span>&nbsp;·&nbsp;8 min&nbsp;|&nbsp;<a href=https://github.com/raqystyle/raqystyle.github.io/content/blog/dependencies-on-frontend-frameworks.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>As modern front-end applications become increasingly complex, it is becoming more and more important to maintain the separation of concerns between the view layer and the business logic.</p><h2 id=new-toys-old-problems>New toys, old problems<a hidden class=anchor aria-hidden=true href=#new-toys-old-problems>#</a></h2><p>Having seen several modern codebases, I can say that history is repeating itself. Back in the day, when PHP was growing in popularity, but the ecosystem was not mature enough, the separation of concerns was a hot topic. For example, rushing to deliver the working code on time, people would query or write to a database directly from the views.</p><p>Today we use a different tech stack, but the principles remain the same. With the rise of single-page applications and front-end frameworks, the boundaries between concerns have blurred. Consider a component-based model. The key mantra is that a UI component is an isolated, drop-in piece of a larger system. A component acts as an encapsulation mechanism. Nobody cares what happens inside of that component. But this is exactly how we get ourselves into the &ldquo;I only wanted a banana, but I got a gorilla and the whole jungle with it&rdquo; situation.</p><p>For example, our little Autocomplete UI component can read directly from the API via a service (we often pretend to follow the best practices). Later, the same component can import something called a &ldquo;UI Manager&rdquo; and manipulate some other part of the system via an event. All of this may sound unreal, but I have just described a part of a real codebase.</p><p>Moreover, every codebase is bound to end-up like this for several reasons:</p><ul><li>People writing code who are unaware of simple engineering principles;</li><li>Poor planning leading to unrealistic deadlines;</li><li>The evaluation of people&rsquo;s output is unbalanced.</li></ul><p>In other words, when inexperienced people have to cut corners to meet a deadline, neglecting the quality aspects or architectural principles, we end-up in a situation like this. This problem gets exacerbated when lead engineers or engineering managers are judged solely on speed of delivery of their teams.</p><h2 id=so-why-is-it-a-problem>So, why is it a problem?<a hidden class=anchor aria-hidden=true href=#so-why-is-it-a-problem>#</a></h2><p>Everything works, doesn&rsquo;t it? Of course it does! Why shouldn&rsquo;t it? But because the business logic is spread across the view layer and data is being accessed and written everywhere, the system becomes almost untestable. All of this leads to lesser confidence in developers when they change the code and makes it harder to guarantee that the system will work in the next release. As a result, we end up performing hot fixes during releases and, worst of all, reduced customer confidence and satisfaction.</p><p>And as we all know, there&rsquo;s nothing more permanent than a temporary solution. So, all the quick hacks stay there for a long time. In addition, people leave the company and new people come in. These new people will have to be productive with the code they have inherited. For them it is now legacy code. Also, the business will evolve, some features will become obsolete, some will become really complex. All of that means changing the code. But nobody wants to break the working system. Thus, some people will call for refactoring, others will insist on rewriting. But for business, however, refactoring will only makes sense if it opens the door to more revenue. The problem is that the longer the code remains in this state of mixed concerns, the more expensive it becomes to fix the code.</p><p>The analogy I use is a fancy restaurant with a neglected kitchen. If nobody cleans the kitchen regularly, eventually the restaurant will have to close for a while and clean up. Closing the restaurant will be far more expensive than regular cleaning.</p><h2 id=an-example>An example<a hidden class=anchor aria-hidden=true href=#an-example>#</a></h2><p>I&rsquo;ll include a few code snippets here to illustrate my ideas. I have deliberately left out some important (but not very relevant to the topic of this post) details.</p><p>Let&rsquo;s take a look at the Autocomplete UI component. In it&rsquo;s simplest form, it should act as a simple input with a list of hints that get fetched from a source and displayed to the user. A user can click on a hint to send that value to the component&rsquo;s consumer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>debounce</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;debounce.library&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>AutocompleteList</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;@components/AutocompleteList&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>AutocompleteService</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;@services/AutocompleteService&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Autocomplete</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>items</span>, <span style=color:#a6e22e>setItems</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>([]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetchItems</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>currentValue</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>AutocompleteService</span>
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>fetchItems</span>(<span style=color:#a6e22e>currentValue</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>data</span> =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>setItems</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>debouncedFetchItems</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>debounce</span>(<span style=color:#a6e22e>fetchItems</span>, <span style=color:#ae81ff>300</span>)
</span></span><span style=display:flex><span>  }, []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>onChange</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>debouncedFetchItems</span>} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>AutocompleteList</span> <span style=color:#a6e22e>items</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>items</span>} /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On the face of it, this is a fairly common implementation. However, if I want to reuse the autocomplete in a different context, I&rsquo;ll also get the <code>AutocompleteService</code> and <code>AutocompleteList</code> too, even though I only asked for the <code>Autocomplete</code> UI component.</p><p>Now let&rsquo;s say we need to add a way to add a missing suggestion. So, we&rsquo;ll add a small button at the bottom of the list that will open a dialogue box to add an item to the suggestion list. A few weeks later, we realise that the suggestions on a particular page need to be personalised for the current user. I think you can see how complex this small component can become.</p><p>So, how do we fix this situation? Let&rsquo;s focus on the code listed above. The first thing I would do is make sure that there&rsquo;s no direct import of a service into the UI component. Instead, we should declare an interface for our users to implement. Let me illustrate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Suggestion</span> <span style=color:#f92672>=</span> { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AutocompleteProps</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fetchSuggestions</span>(<span style=color:#a6e22e>userInput</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Suggestion</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Autocomplete</span>(<span style=color:#a6e22e>props</span>: <span style=color:#66d9ef>AutocompleteProps</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetchItems</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>event</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>currentValue</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>props</span>
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>fetchSuggestions</span>(<span style=color:#a6e22e>currentValue</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>setItems</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>By declaring this interface, <code>Autocomplete</code> frees itself from any notion of services or data stores or apis or whatever. This is called the principle of dependency inversion. By making this change, we get closer to being able to reuse this UI component in other places and feed the information into it from whatever sources. For testing purposes we can simply create a mock implementation of the <code>AutocompleteService</code>.</p><p>This is a great change to make, much cleaner! However, we are not done yet. You see, our Autocomplete UI component consists of a text input and a list of suggestions. By design our component has two responsibilities: collecting user input and displaying suggestions. However, as we anticipated, we now need to modify the suggestion list. Well, if other parts of the application use this component, we need to make sure that we don&rsquo;t accidentally introduce a new functionality to them as well. We could, of course, tinker with the props, or make a copy of the whole component. But there&rsquo;s a much better way.</p><p>There&rsquo;s a principle of a single responsibility. In our case, we need to treat a suggestion list as a separate component, not the part of the Autocomplete component. We should also pass it to the Autocomplete via props, rather than importing it directly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AutocompleteProps</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>suggestionsList</span>: <span style=color:#66d9ef>ReactNode</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Autocomplete</span>(<span style=color:#a6e22e>props</span>: <span style=color:#66d9ef>AutocompleteProps</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>suggestionsList</span>}
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this particular example, we delegate the responsibility for implementing or importing the correct suggestion list to the consumer of the autocomplete component. We, as the component authors, can provide a default suggestion list.</p><h2 id=not-just-ui-components>Not just UI components<a hidden class=anchor aria-hidden=true href=#not-just-ui-components>#</a></h2><p>Although, we have focused on the UI code, these principles apply to any other type of code. For example, if you are working on an Electron-based application and need to import something from the <code>electron</code> package, stop and create an interface. You will be amazed at how easy it is to test the business logic, rather than worrying about spinning up an instance of electron when running unit tests.</p><p>Although I&rsquo;ve shown the benefits of injecting dependencies, that doesn&rsquo;t mean I&rsquo;m against imports. During code review, look for imports from packages we don&rsquo;t control and ask the author to create an interface. This interface should convey the intent. For example, instead of using <code>localStorage</code> directly, create an interface with methods like <code>saveUserMetadata</code> or <code>getGameScore</code>. In the class that implements this interface, feel free to use the <code>localStorage</code>, an <code>apiServer</code>, memory or whatever you want.</p><h2 id=risk-for-business>Risk for business<a hidden class=anchor aria-hidden=true href=#risk-for-business>#</a></h2><p>Typically, frameworks are maintained and developed by third parties. Dependencies on third parties are always risky: the organisation could end up with an abandoned framework. If engineers respect the principle of separation of concerns, replacing this layer would be much less expensive.</p><p>Another point is that the framework&rsquo;s licence may change and become too expensive. In this case, without a clean boundary between the business logic and the view layer, the cost of refactoring can be too high for the organisation.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Frameworks may seem like the solution to all our problems. But they are not. In the software engineering community, especially in the front-end camp, frameworks are glorified as the way forward, the way to build software. However, very few talk about the problems associated with this kind of thinking, and how to avoid the framework trap.</p><p>Over the years, people have distilled simple but powerful engineering principles that, in my opinion, every engineer should know. The ones I talked about in this article are so called SOLID principles. They are easy to learn as there are plenty of resources available online. If you prefer books, I&rsquo;d recommend &ldquo;Clean Architecture&rdquo; by Robert C. Martin.</p><p>At first, following these principles may seem like extra work. But these ideas are not a rocket science and are very easy to understand. Over time using them becomes a second nature. So, don&rsquo;t be intimidated.</p><p>Engineering culture (and work culture, for that matter) is also an important issue to consider. Time to market is an important metric. But code quality, architectural flexibility and testability are equally (if not more) important in the long run.</p><p>In my opinion, the companies that pay close attention to code quality have an advantage in the market. Similar to a restaurant that maintains both a high quality of food and a clean kitchen.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://raqystyle.github.io/tags/architecture/>architecture</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://raqystyle.github.io/>Ivan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript>var sc_project=12781072,sc_invisible=1,sc_security="4d31877b"</script><script type=text/javascript src=https://www.statcounter.com/counter/counter.js async></script><noscript><div class=statcounter><a title="Web Analytics" href=https://statcounter.com/ target=_blank><img class=statcounter src=https://c.statcounter.com/12781072/0/4d31877b/1/ alt="Web Analytics" referrerpolicy=no-referrer-when-downgrade></a></div></noscript><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>